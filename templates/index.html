{% extends 'base.html' %}
{% block head %}
{% include 'modules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/croptop_deployer.html' %}
{% include 'modules/operator_store.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const postModal = document.getElementById("post-modal");
    postModal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div id="top-dom">
  {% include 'modules/header.html' %}
</div>
<div id="body-dom">
  <div id="posts-loading-animation" class="body-loading-animation loading-animation"></div>
  <div id="post-frames-container" style="display: none"></div>
  <div id="post-list-container"></div>
</div>
<div id="fork-modal" class="modal negative-space">
  <div class="modal-content content negative-space">
    <div class="exit-button mobile-padding negative-space">[<span class="exit-button-text negative-space">close</span>]</div>
    {% include 'modules/fork.html' %}
  </div>
</div>
<div id="post-modal" class="modal negative-space">
  <div class="modal-content content negative-space">
    <div class="exit-button mobile-padding negative-space">[<span class="exit-button-text negative-space">close</span>]</div>
    {% include 'modules/post.html' %}
  </div>
</div>
<script>
  // Layout constants.
  const horizontalMargin = 20;
  const verticalMargin = 20;
  const postFrameWidthClasses = ["post-frame-w1", "post-frame-w2", "post-frame-w3"];
  const formInputReactionTimeDelay = 600;
  const noScrollEffectEdgeDistance = 80;
  const pagingEdgeDistance = 1000;
  const toggleNavVisibilityScrollThreshold = 50;

  // State constants.
  const feeDivisor = 20;

  // Layout variables.
  let postFrames = [];
  let postRows = [];
  let posts = [];
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];
  let lastScrollTop = 0;

  // State variables.
  let defaultPageSize = 20;
  let currentPage = 0;
  let canLoadNewPosts = true;

  const loadPostsState = async (encodedIPFSUris) => {
    // Load tiers.
    const postFormStateChain = document.getElementById("post-form-state-chain");
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const chain = postFormStateChain.innerHTML;
    const projectId = parseInt(postFormStateProjectId.innerHTML);

    const tiers = await tx_view_tiers(projectId, encodedIPFSUris, resolveChainId(chain));

    for (let i in tiers) {
      const tier = tiers[i];
      if (tier.id == 0) continue;

      // Cache the value.
      if (!tiersCache[projectId]) tiersCache[projectId] = {};
      tiersCache[projectId][encodedIPFSUris[i]] = tier;
    }
  }

  const decoratePostFrameState = (postFrame,  projectId, encodedIPFSUri) => {
    if (!tiersCache[projectId]) tiersCache[projectId] = {};
    const tier = tiersCache[projectId][encodedIPFSUri];
    if (!tier) return;

    // Get a reference to the tier's remaining supply.
    const formattedRemainingSupply = parseInt(tier[2].toString());
    const state = postFrame.querySelector(".post-frame-state");

    // Set the content.
    if (formattedRemainingSupply == 0) {
      state.innerHTML = 'sold out';
      state.classList.add("alert");
    } else {
      state.textContent = `${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left`;
    }
  }

  const decoratePostRowState = (postRow,  projectId, encodedIPFSUri) => {
    if (!tiersCache[projectId]) tiersCache[projectId] = {};
    const tier = tiersCache[projectId][encodedIPFSUri];
    if (!tier) return;

    // Get a reference to the tier's remaining supply.
    const formattedRemainingSupply = parseInt(tier[2].toString());
    const state = postRow.querySelector(".post-row-state");

    // Set the content.
    if (formattedRemainingSupply == 0) {
      state.innerHTML = 'sold out';
      state.classList.add("alert");
    } else {
      state.textContent = `${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left`;
    }
  }

  const decoratePostFrame = async (postFrame, postId, date, name, link, imageSrc, videoSrc) => {
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const projectId = parseInt(postFormStateProjectId.innerHTML);

    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "(untitled)";

    const postModal = document.getElementById("post-modal");

    // Get references to frame elements that need decorating.
    const subtitle = postFrame.querySelector(".post-frame-subtitle");
    const title = postFrame.querySelector(".post-frame-title");
    const frameImage = postFrame.querySelector("img");
    const frameVideo = postFrame.querySelector("video");

    // Set the frame and img's ID.
    postFrame.id = 'frame-' + postId;
    frameImage.id = 'img-' + postId;
    frameVideo.id = 'img-' + postId;

    // Set the content.
    title.innerHTML = name;
    subtitle.innerHTML = `${date} | <span class="post-frame-state">recordable</span>`;

    if (name == "✃") title.classList.add("bigger-font"); 

    if (videoSrc) {
      frameImage.style.display = "none"
      frameVideo.style.display = "block"
      frameVideo.autoplay = false;
      frameVideo.loop = true;
      frameVideo.muted = true;
      frameVideo.controls = false;
      // Mark videos with an icon.
      subtitle.innerHTML = `${subtitle.innerHTML} | [▶]`
      frameImage.src = "";
      frameVideo.src = videoSrc;
      frameImage.loading = "lazy";
      frameVideo.addEventListener("mouseover", frameVideo.play);
      frameVideo.addEventListener("mouseout", frameVideo.pause);
    } else {
      frameImage.style.display = "block"
      frameVideo.style.display = "none"
      frameVideo.src = "";
      frameImage.src = imageSrc;
      frameImage.loading = "lazy";
    }

    const encodedIPFSUri = await encodeIPFSUriFrom("{{ assets_prefix }}", postId);

    // Summon a modal when the frame is clicked.
    postFrame.addEventListener("click", async (e) => {
      e.preventDefault();
      
      // Pause the video.
      // If there's a video, pause it.
      if (videoSrc) frameVideo.pause();

      // Show the modal.
      postModal.style.display = "block";

      toggleNavVisibility();

      // Make the modal look right.
      await decoratePostModal(postId, encodedIPFSUri, name, date, link, imageSrc, videoSrc);
    });

    decoratePostFrameState(postFrame, projectId, encodedIPFSUri);
  }

  const decoratePostRow = async (postRow, postId, date, name, link, imageSrc, videoSrc) => {
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const projectId = parseInt(postFormStateProjectId.innerHTML);

    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "(untitled)";

    const postModal = document.getElementById("post-modal");

    // Get references to frame elements that need decorating.
    const subtitle = postRow.querySelector(".post-row-subtitle");
    const title = postRow.querySelector(".post-row-title");
    const imageContainer = postRow.querySelector(".post-row-image-container");
    const rowImage = postRow.querySelector("img");
    const rowVideo = postRow.querySelector("video");

    // Set the frame and img's ID.
    postRow.id = 'row-' + postId;
    rowImage.id = 'img-' + postId;
    rowVideo.id = 'img-' + postId;

    // Set the content.
    title.innerHTML = name;
    subtitle.innerHTML = `${date} | <span class="post-row-state">recordable</span>`;

    if (name == "✃") title.classList.add("bigger-font"); 

    if (videoSrc) {
      rowImage.style.display = "none"
      rowVideo.style.display = "block"
      rowVideo.autoplay = false;
      rowVideo.loop = true;
      rowVideo.muted = true;
      rowVideo.controls = false;
      // Mark videos with an icon.
      subtitle.innerHTML = `${subtitle.innerHTML} | [▶]`
      rowImage.src = "";
      rowVideo.src = videoSrc;
      rowImage.loading = "lazy";
      rowVideo.addEventListener("mouseover", rowVideo.play);
      rowVideo.addEventListener("mouseout", rowVideo.pause);
      subtitle.innerHTML = `${subtitle.innerHTML} | [▶]`
    } else {
      rowImage.style.display = "block"
      rowVideo.style.display = "none"
      rowVideo.src = "";
      rowImage.src = imageSrc;
      rowImage.loading = "lazy";
    }

    const encodedIPFSUri = await encodeIPFSUriFrom("{{ assets_prefix }}", postId);

    // Summon a modal when the frame is clicked.
    postRow.addEventListener("click", async (e) => {
      e.preventDefault();

      // Show the modal.
      postModal.style.display = "block";

      toggleNavVisibility();

      // Make the modal look right.
      await decoratePostModal(postId, encodedIPFSUri, name, date, link, imageSrc, videoSrc);
    });

    decoratePostRowState(postRow, projectId, encodedIPFSUri);
  }

  /// Load the frame contents.
  const loadPostImage = async (container) => {
    const img = container.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }

      checkForDimensions();
    });
  }

  /// Get the top.
  const getTopTarget = (postFrame, row) => {
    if (row == 1) {
      const framesContainer = document.getElementById("post-frames-container");
      return framesContainer.offsetTop;
    }

    let previousRow = rows[row - 2];
    let candidatePostFrame;

    for (let j = 0; j < previousRow.postFrameReferences.length; j++) {
      let postFrameToCheck = previousRow.postFrameReferences[j];

      if (
        postFrame.left < postFrameToCheck.right + horizontalMargin &&
        postFrame.right + horizontalMargin > postFrameToCheck.left &&
        (candidatePostFrame == null || postFrameToCheck.bottom > candidatePostFrame.bottom)
      ) candidatePostFrame = postFrameToCheck;
      else if (j == previousRow.postFrameReferences.length - 1 && postFrame.left >= postFrameToCheck.right + horizontalMargin) {
        return candidatePostFrame ? candidatePostFrame.bottom : getTopTarget(postFrame, row - 1);
      }
    }

    if (!candidatePostFrame) {
      console.log({ postFrame, row, previousRow });
    }

    return candidatePostFrame.bottom;
  }

  const framePost = () => {
    const framesContainer = document.getElementById("post-frames-container");
    const frame = document.createElement("div");
    const infoContainer = document.createElement("div");
    const info = document.createElement("div");
    const title = document.createElement("div");
    const subtitle = document.createElement("div");
    const image = document.createElement("img");
    const video = document.createElement("video");

    frame.classList.add("post-frame");
    infoContainer.classList.add("post-frame-info-container");
    info.classList.add("post-frame-info");
    subtitle.classList.add("post-frame-subtitle");
    title.classList.add("post-frame-title");

    // Get random width.
    const widthClass = postFrameWidthClasses[Math.floor(Math.random() * postFrameWidthClasses.length)];
    frame.classList.add(widthClass);

    info.appendChild(title);
    info.appendChild(subtitle);
    infoContainer.appendChild(info);
    frame.appendChild(infoContainer);
    frame.appendChild(image);
    frame.appendChild(video);
    framesContainer.appendChild(frame);

    return frame;
  }

  const listPost = () => {
    const listContainer = document.getElementById("post-list-container");
    const rowContainer = document.createElement("div");
    const row = document.createElement("div");
    const info = document.createElement("div");
    const title = document.createElement("div");
    const subtitle = document.createElement("div");
    const imgContainer = document.createElement("div");
    const image = document.createElement("img");
    const video = document.createElement("video");

    rowContainer.classList.add("post-row-container");
    row.classList.add("post-row");
    info.classList.add("post-row-info");
    title.classList.add("post-row-title");
    subtitle.classList.add("post-row-subtitle");
    imgContainer.classList.add("post-row-image-container");

    info.appendChild(title);
    info.appendChild(subtitle);
    imgContainer.appendChild(image);
    imgContainer.appendChild(video);
    row.appendChild(imgContainer);
    row.appendChild(info);
    rowContainer.appendChild(row);
    listContainer.appendChild(rowContainer);

    return row;
  }

  const positionAndShowPostFrame = async (postFrame) => {
    await loadPostImage(postFrame);

    if (loadingAnimationIntervals['posts-loading-animation']) stopLoadingAnimation('posts-loading-animation');

    const rect = postFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;

    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
    const newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ postFrameReferences: [newFrame] });
    else rows[rows.length - 1].postFrameReferences.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = window.getComputedStyle(postFrame).display == "block" ? 0 : heightDiff + scrollTop - verticalMargin;
    postFrame.classList.add("post-frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            postFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        postFrame.addEventListener("transitionend", handleEvent);
        postFrame.style.marginTop = -marginTop + "px";
      } else resolve();
    });
  }

  const positionAndShowPostRow = async (postRow) => {
    await loadPostImage(postRow);

    if (loadingAnimationIntervals['posts-loading-animation']) stopLoadingAnimation('posts-loading-animation');

    postRow.classList.add("post-row-fade-in");
  }

  const decoratePostModal = async (postId, encodedIPFSUri, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.
    const postModal = document.getElementById("post-modal");
    const topDom = document.getElementById("top-dom");
    const headerContainer = document.getElementById("header-container");
    const postFormStateReveal = document.getElementById("post-form-state-reveal");
    const postFormErrorMessage= document.getElementById("post-form-error-message");
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");
    const postImage = document.getElementById("post-cover-image");
    const postVideo = document.getElementById("post-cover-video");

    requestAnimationFrame(() => {
      const headerContainerHeight = headerContainer.offsetHeight;
      const borderHeight = parseInt(topDom.style.borderBottomWidth, 10);
      postModal.style.paddingTop = headerContainerHeight + borderHeight + 'px';
    });

    // Track the modal in browse history.
    history.pushState({ modalOpened: true, postId }, "", "?id=" + postId);

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    postModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    postModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("negative-space")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT") return;

      // If there's a video, pause it.
      if (videoSrc) postVideo.pause();

      // Hide the RECORD form.
      recordPostForm.style.display = "none";
      // Hide the COLLECT form.
      collectPostForm.style.display = "none";
      // Hide the error message.
      postFormErrorMessage.style.display = "none";
      // Close the state reveal.
      postFormStateReveal.open = false;
      // Hide the content
      postImage.style.display = "none"
      postVideo.style.display = "none"

      // Hide the modal.
      postModal.style.display = "none";

      toggleNavVisibility();

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
    });

    // Show the post page.
    await decoratePostPage(name, date, link, imageSrc, videoSrc, encodedIPFSUri);
  }

  // Get the fork modal set up.
  const decorateForkModal = () => {
    // Get references to elements that need decorating.
    const forkModal = document.getElementById("fork-modal");
    const topDom = document.getElementById("top-dom");
    const headerContainer = document.getElementById("header-container");

    // Adjust the size.
    requestAnimationFrame(() => {
      const headerContainerHeight = headerContainer.offsetHeight;
      const borderHeight = parseInt(topDom.style.borderBottomWidth, 10);
      forkModal.style.paddingTop = headerContainerHeight + borderHeight + 'px';
    });

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    forkModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    forkModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("negative-space")) return;

      // Ignore if the clicked view comes while an input, select, or textarea field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT" || activeElementOnClose.tagName === "TEXTAREA") return;

      // Hide the modal.
      forkModal.style.display = "none";

      toggleNavVisibility();
    });

    decorateNewJbForm();
    decoratePermissionForm();
    decorateAllowanceForm();
  }

  const showPostFrames = async (newPosts) => {
    const newPostFrames = newPosts.map((post) => {
      // if post.hasVideo, use _videoThumbnail.png
      // else use a random attachment
      const imageName = post.hasVideo ? '_videoThumbnail.png' : post.attachments[Math.floor(Math.random() * post.attachments.length)];
      const imageSrc = './' + post.id + '/' + imageName;
      const videoSrc = post.hasVideo ? './' + post.id + '/' + post.videoFilename : null;
      const frame = framePost();
      decoratePostFrame(frame, post.id, formatTimestamp(post.created), post.title, post.externalLink, imageSrc, videoSrc);
      return frame;
    });
    postFrames = postFrames.concat(newPostFrames);

    for (const postFrame of newPostFrames)
      await positionAndShowPostFrame(postFrame);
  }

  const showPostList = async (newPosts) => {
    const newPostRows = newPosts.map((post) => {
      // if post.hasVideo, use _videoThumbnail.png
      // else use a random attachment
      const imageName = post.hasVideo ? '_videoThumbnail.png' : post.attachments[Math.floor(Math.random() * post.attachments.length)];
      const videoSrc = post.hasVideo ? './' + post.id + '/' + post.videoFilename : null;
      const imageSrc = './' + post.id + '/' + imageName;
      const row = listPost();
      decoratePostRow(row, post.id, formatTimestamp(post.created), post.title, post.externalLink, imageSrc, videoSrc);
      return row;
    });
    postRows = postRows.concat(newPostRows);

    for (const postRow of newPostRows)
      await positionAndShowPostRow(postRow);
  }

  const showPosts = async (posts) => {
    const framesContainer = document.getElementById("post-frames-container");
    const listContainer = document.getElementById("post-list-container");

    if (postMode == "frames") {
      framesContainer.style.display = "block";
      listContainer.style.display = "none";
      await showPostFrames(posts);
    } else {
      framesContainer.style.display = "none";
      listContainer.style.display = "block";
      await showPostList(posts);
    }
  }

  const loadPosts = async (pageSize) => {
    canLoadNewPosts = false;
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const startingIndex = currentPage*pageSize;
    const newPosts = data['articles']
      .slice(startingIndex, startingIndex + pageSize)
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(post => post.hasVideo === true || post.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)));

    posts = posts.concat(newPosts);

    if (!newPosts.length) return;

    currentPage++;

    const encodedIPFSUris = await Promise.all(posts.map(async (post) => await encodeIPFSUriFrom("{{ assets_prefix }}", post.id)));

    await loadPostsState(encodedIPFSUris);

    await showPosts(newPosts);

    canLoadNewPosts = true;
  }

  const toggleNavVisibility = () => {
    const navContainer = document.getElementById('nav-container');

    const topDom = document.getElementById('top-dom');
    const postModal = document.getElementById('post-modal');
    const forkModal = document.getElementById('fork-modal');
    const headerContainer = document.getElementById('header-container');

    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const maxScrollTop = document.documentElement.scrollHeight - document.documentElement.clientHeight;

    const show = () => {
      let navContainerHeight = 0;
      if (navContainer) {
        navContainer.style.visibility = "visible";
        navContainer.style.opacity = 1;
        navContainer.classList.remove("hidden");
        navContainerHeight = navContainer.offsetHeight;
      }
      topDom.style.height = headerContainer.offsetHeight + navContainerHeight + "px";
    }
    const hide = () => {
      if (navContainer) {
        navContainer.style.visibility = "hidden";
        navContainer.style.opacity = 0;
        navContainer.classList.add("hidden");
      }
      topDom.style.height = headerContainer.offsetHeight + "px";
    }

    if (postModal.style.display == "block" || forkModal.style.display == "block") {
      hide();
      topDom.style.borderBottomWidth = "1px";
    } else {
      if (currentScrollTop <= 0) {
        show();
        topDom.style.borderBottomWidth = "0px";
      } else {
        topDom.style.borderBottomWidth = "1px";
        if (Math.abs(currentScrollTop - lastScrollTop) < toggleNavVisibilityScrollThreshold) return;
        if (lastScrollTop > noScrollEffectEdgeDistance && maxScrollTop - lastScrollTop > noScrollEffectEdgeDistance) {
          if (currentScrollTop > lastScrollTop) hide();
          else show();
        }
      }
      lastScrollTop = currentScrollTop;
    }
  }

  const pageMorePostsIfNeeded = () => {
    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const maxScrollTop = document.documentElement.scrollHeight - document.documentElement.clientHeight;

    if (canLoadNewPosts && maxScrollTop - currentScrollTop < pagingEdgeDistance)
      loadPosts(defaultPageSize);
  }

  const didScroll = () => {
    toggleNavVisibility();
    pageMorePostsIfNeeded();
  }

  const setTopDomHeight = () => {
    const topDom = document.getElementById('top-dom');
    const headerContainer = document.getElementById('header-container');
    const navContainer = document.getElementById('nav-container');
    const navHeight = navContainer ? navContainer.offsetHeight : 0;
    topDom.style.height = headerContainer.offsetHeight + navHeight + "px";
  }

  const setupPostMode = () => {
    const postModeButton = document.getElementById("post-mode-button");
    postModeButton.addEventListener('click', () => showPosts(posts));
  }

  // if there is ?id= in the url, open the object page.
  const urlParams = new URLSearchParams(window.location.search);
  const id = urlParams.get('id');
  if (id) {
    window.location.href = './' + id + '/';
  } else {
    window.addEventListener("load",  setTopDomHeight);
    window.addEventListener("resize", setTopDomHeight);
    window.addEventListener("scroll", didScroll);

    startLoadingAnimation('posts-loading-animation');
    loadSettings();
    setupForking();
    loadPosts(defaultPageSize);
    setupPostMode();
  }
</script>
{% endblock %}
