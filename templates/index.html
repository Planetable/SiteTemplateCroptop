{% extends 'base.html' %}
{% block head %}
{% include 'modules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/croptop_deployer.html' %}
{% include 'modules/operator_store.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const postModal = document.getElementById("post-modal");
    postModal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div id="top-dom">
  <div id="top">
    {% if has_avatar == true %}
    <img src="{{ assets_prefix }}avatar.png" width="72" height="72" class="avatar">
    {% endif %}
    <div class="site-info">
      <div class="site-title">{{ page_title|escape }}</div>
      {% if page_description_html.count > 0 %}<div class="site-about">{{ page_description_html }}</div>{% endif %}
    </div>
    <div id="fork">fork</div>
    {% include 'modules/social_icons.html' %}
  </div>
  {% include 'modules/nav.html' %}
</div>
<div id="frames-dom">
  <div id="main-loading-animation" class="loading-animation"></div>
  <div id="frames"></div>
</div>
<div id="fork-modal" class="modal closes-modal">
  <div class="modal-content closes-modal">
    <div class="modal-close closes-modal">[close]</div>
    <div class="modal-header closes-modal">
        To set up your site and learn how to start posting, follow the instructions at <a href="https://croptop.eth.limo" target="_blank">https://croptop.eth</a>.
      <div class="fork-info">
        If you want to let people pay you to record content onchain, you'll first need to create a Juicebox — an open source, community built & owned, and onchain programmable vending machine. You'll then add your Juicebox project ID into the settings of the Croptop app.
      </div>
      <div class="fork-info">
        You can create a simple Croptop-compatible Juicebox below. You can adjust it later on <a href="https://juicebox.money" target="_blank">https://juicebox.money</a>. It's recommended to send these transactions from the same forms over at <a href="https://croptop.eth.limo" target="_blank">https://croptop.eth</a> to make sure they haven't been tampered with.
      </div>
    </div>
    <div id="fork-form" class="form closes-modal">
      <div class="form-body">
        <div class="form-section">
          <div class="form-item">
            <div class="form-label">Chain</div>
            <div class="form-value form-select-value">
              <select id="fork-form-state-chain-input" name="chain">
                {# <option value="mainnet">mainnet</option> #}
                <option value="goerli">goerli</option>
              </select>
            </div>
          </div>
        </div>
        <details>
          <summary class="toggle main-toggle">Make a new Juicebox</summary>
          <div class="form-section">
            <div class="form-section-description">Once deployed, you can find your Juicebox's project ID by looking for new projects at <a href="https://juicebox.money/projects?tab=new" target="_blank">https://juicebox.money/projects?tab=new</a>. The owner you set can edit this project at any time to change its description or set new money rules.</div>
            <div class="form-item">
              <div class="form-label">Collection name</div>
              <div class="form-value">
                <input type="text" placeholder="Your collection name" id="fork-form-new-jb-collection-name-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Collection Symbol</div>
              <div class="form-value">
                <input type="text" placeholder="POSTS" id="fork-form-new-jb-collection-symbol-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item form-item-large">
              <div class="form-label">Owner 
                <button id="fork-form-new-jb-load-address-button" class="load-address-button">[<span class="load-address-button-text">connect wallet</span>]</button>
              </div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="fork-form-new-jb-project-owner-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-section-description">A post's minting parameters are chosen by the collector at the time they record it onchain. Anyone can post any content from anywhere to your Juicebox, so long as these allowances that you set are met.</div>
            <div class="form-item">
              <div class="form-label">Minimum price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" placeholder="free" value="0.01" id="fork-form-new-jb-minimum-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Min total supply</div>
              <div class="form-value">
                <input type="number" value="1" id="fork-form-new-jb-minimum-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Max total supply</div>
              <div class="form-value">
                <input type="number" placeholder="unlimited" id="fork-form-new-jb-maximum-total-supply-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item form-item-large">
              <div class="form-label">Allowed posting addresses (one per line)</div>
              <div class="form-value">
                <textarea rows="4" id="fork-form-new-jb-addresses-input" placeholder="leave empty for no restrictions"></textarea>
              </div>
            </div>
          </div>
          <div id="fork-form-new-jb-error-message" class="form-error-message"></div>
          <button id="fork-form-new-jb-submit-button" class="form-button">[<span id="fork-form-new-jb-submit-button-text" class="form-button-text">deploy project</span>]<span id="fork-form-new-jb-button-loading-animation" class="loading-animation button-loading-animation"></span></button> 
        </details>
        <details>
          <summary class="toggle main-toggle">Let Croptop post to your Juicebox on your behalf</summary>
          <div class="form-section">
            <div class="form-section-description">Give the Croptop contract posting permissions to your Juicebox on your behalf.</div>
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value">
                <input type="number" placeholder="420" id="fork-form-operator-project-id-input">
              </div>
            </div>
          </div>
          <div id="fork-form-permission-error-message" class="form-error-message"></div>
          <button id="fork-form-permission-submit-button" class="form-button">[<span id="fork-form-permission-submit-button-text" class="form-button-text">give permission</span>]<span id="fork-form-permission-button-loading-animation" class="loading-animation button-loading-animation"></span></button> 
        </details>
        <details>
          <summary class="toggle main-toggle">Set who can post to your Juicebox through Croptop</summary>
          <div class="form-section">
            <div class="form-section-description">Add new conditions that posts must meet when made to your Juicebox through Croptop.</div>
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value">
                <input type="number" placeholder="420" id="fork-form-allowance-project-id-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-section-description">A post's minting parameters are chosen by the collector at the time they record it onchain. Anyone can post any content from anywhere to your Juicebox, so long as these allowances that you set are met.</div>
            <div class="form-item">
              <div class="form-label">Minimum price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" placeholder="free" value="0.01" id="fork-form-allowance-minimum-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Min total supply</div>
              <div class="form-value">
                <input type="number" value="1" id="fork-form-allowance-minimum-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Max total supply</div>
              <div class="form-value">
                <input type="number" placeholder="unlimited" id="fork-form-allowance-maximum-total-supply-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item form-item-large">
              <div class="form-label">Allowed posting addresses (one per line)</div>
              <div class="form-value">
                <textarea rows="4" id="fork-form-allowance-addresses-input" placeholder="leave empty for no restrictions"></textarea>
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">NFT category on your Juicebox for which the above allowances apply</div>
              <div class="form-value">
                <input type="number" value="0" id="fork-form-allowance-nft-category-input">
              </div>
            </div>
          </div>
          <div id="fork-form-allowance-error-message" class="form-error-message"></div>
          <button id="fork-form-allowance-submit-button" class="form-button">[<span id="fork-form-allowance-submit-button-text" class="form-button-text">save allowances</span>]<span id="fork-form-allowance-button-loading-animation" class="loading-animation button-loading-animation"></span></button> 
        </details>
      </div>
    </div>
  </div>
</div>
<div id="post-modal" class="modal closes-modal">
  <div class="modal-content closes-modal">
    <div class="modal-close closes-modal">[close]</div>
    <div class="modal-header closes-modal">
      <span id="frame-date"></span><span id="frame-name"></span>
      <div id="frame-subtitle" class="closes-modal">
          <span id="frame-link"></span>
      </div>
      <div id="post-form-state" class="closes-modal">
        <details id="post-form-state-reveal">
          <summary id="post-form-state-toggle" class="toggle"><span id="post-form-state-chain" class="post-form-state-item-value"></span>, project ID: <a id="post-form-state-project-id" class="post-form-state-item-value" target="_blank"></a>, NFT category ID: <span id="post-form-state-nft-category" class="post-form-state-item-value"></span></summary>
          <div class="form-section-description">Specify the Juicebox project that is being funded from this NFT sale and the category under which it will appear. Changing these values will change the availability of this NFT.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Chain</div>
              <div class="form-value form-select-value">
                <select id="post-form-state-chain-input" name="chain">
                  {# <option value="mainnet">mainnet</option> #}
                  <option value="goerli">goerli</option>
                </select>
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value"><input type="number" value="" id="post-form-state-project-id-input"></div>
            </div>
            <div class="form-item">
              <div class="form-label">NFT category ID</div>
              <div class="form-value"><input type="number" value="" id="post-form-state-nft-category-input"></div>
            </div>
          </div>
          <div id="post-form-state-error-message" class="form-error-message"></div>
          <button id="post-form-state-button" class="form-button">[<span id="post-form-state-button-text" class="form-button-text">update</span>]</button>
        </details>
      </div>
    </div>
    <div id="collect-post-form" class="form closes-modal">
      <span id="collect-post-form-header" class="form-header"></span>
      <div class="form-body">
        <details id="collect-post-form-options-reveal">
          <summary id="collect-post-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Determine the price you want to pay and the address that will be sent the copy you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" value="" id="collect-post-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="collect-post-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address <button id="collect-post-form-load-address-button" class="load-address-button">[<span class="load-address-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="collect-post-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
          <details id="collect-post-form-disclaimer-reveal">
            <summary id="collect-post-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary</summary>
            <div class="form-section">
              <div class="form-item form-item-large">
                <div class="form-label">$CPN Beneficiary Address</div>
                <div class="form-value">
                  <input type="text" placeholder="Defaults to the address of this site's author" id="collect-post-form-cpn-beneficiary-input">
                </div>
              </div>
            </div>
          </details>
        </details>
      </div>
    </div>
    <div id="record-post-form" class="form closes-modal">
      <span class="form-header">This file isn't yet onchain. Record it onchain to collect a first copy.</span>
      <div class="form-body">
        <details id="record-post-form-options-reveal">
          <summary id="record-post-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Set the NFT's price, how many editions of this NFT will be made available for collecting, and the address that will be sent its first copies that you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" value="" id="record-post-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Total supply</div>
              <div class="form-value">
                <input type="number" placeholder="10" value="" id="record-post-form-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="record-post-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address 
                <button id="record-post-form-load-address-button" class="load-address-button">[<span class="load-addres-button-text">connect wallet</span>]</button>
              </div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="record-post-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
          <details id="record-post-form-disclaimer-reveal">
            <summary id="record-post-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary</summary>
            <div class="form-section">
              <div class="form-item form-item-large">
                <div class="form-label">$CPN Beneficiary Address</div>
                <div class="form-value">
                  <input type="text" placeholder="Defaults to the address of this site's author" id="record-post-form-cpn-beneficiary-input">
                </div>
              </div>
            </div>
          </details>
        </details>
      </div>
    </div>
    <div id="post-form-modal-loading-animation" class="loading-animation"></div>
    <div id="post-form-error-message" class="form-error-message"></div>
    <button id="post-form-button" class="form-button main-form-button">[<span id="post-form-button-text" class="form-button-text">collect</span>]<span id="post-form-button-loading-animation" class="loading-animation button-loading-animation"></span></button> 
    <img id="modal-image"></img>
    <video id="modal-video"></video>
  </div>
</div>
<script>
  // Layout constants.
  const horizontalMargin = 24;
  const verticalMargin = 10;
  const transitionDuration = 300;
  const widthClasses = ["w1", "w2", "w3"];
  const loadingAnimationPace = 100;
  const formInputReactionTimeDelay = 600;
  const noZcrollEffectEdgeDistance = 80;

  // State constants.
  const feeDivisor = 20;

  // Layout variables.
  let frames;
  let items = [];
  let loadingAnimationIntervals = {};
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];
  let lastScrollTop = 0;

  // State variables.
  let signer;
  let encodedIPFSUris;
  let allowanceCache = {};
  let tiersCache = {};
  let defaultChain = "goerli";  
  let defaultNftCategory = 0;
  let defaultEthAddress;
  let postFormState;
    
  const resolveChainId = (value) => {
    switch (value) {
      case "mainnet": return 1; 
      case "goerli": return 5; 
    }
  }

  const resolveChainSelectIndex = (chain) => {
    switch (chain) {
      {# case "mainnet": return 0;  #}
      case "goerli": return 0; 
    }
  }

  const resolveChain = (chainId) => {
    switch (chainId) {
      case 1: return "mainnet"; 
      case 5: return "goerli"; 
    }
  }

  const cpnProjectId = (chain) => {
    switch (chain) {
      {# case "mainnet": #}
      {#   return 500; #}
      case "goerli":
        return 758;
    }
  }

  const projectLinkBase = (chain) => {
    switch (chain) {
      {# case "mainnet":  #}
      {#   return "https://juicebox.money/v2/p/"; #}
      case "goerli": 
        return "https://goerli.juicebox.money/v2/p/";
    }
  }

  const loadFrameState = async () => { 
    // Load tiers.
    const postFormStateChain = document.getElementById("post-form-state-chain");
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const chain = postFormStateChain.innerHTML;
    const projectId = parseInt(postFormStateProjectId.innerHTML);

    const tiers = await tx_view_tiers(projectId, encodedIPFSUris, resolveChainId(chain));

    for (let i in tiers) {
      const tier = tiers[i];
      if (tier.id != 0) {

        // Cache the value.
        if (!tiersCache[projectId]) tiersCache[projectId] = {};
        tiersCache[projectId][encodedIPFSUris[i]] = tier;

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());
        const frame = frames[i]; 
        const cta = frame.querySelector('.image-cta');

        // Set the content.
        if (formattedRemainingSupply == 0) {
          cta.textContent = '[sold out]';
          cta.classList.add("sold-out");
        } else {
          cta.textContent = `[${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left]`;
        }
      } 
    }
  }

  /// Get admin settings.
  const fetchSettings = () => {
    const postFormStateChain = document.getElementById("post-form-state-chain");
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const postFormStateNftCategory = document.getElementById("post-form-state-nft-category");

    postFormStateChain.innerHTML = defaultChain;
    postFormStateProjectId.innerHTML = cpnProjectId(defaultChain);
    postFormStateNftCategory.innerHTML = defaultNftCategory;

    fetch("{{ assets_prefix }}templateSettings.json")
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        if (data.chain != null) postFormStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        if (data.juiceboxProjectID != null) postFormStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        // data.juiceboxProjectIDGoerli is also available if you need it
        if (data.nftCategory != null) postFormStateNftCategory.innerHTML = Number(data.nftCategory);
        if (data.ethAddress) defaultEthAddress = data.ethAddress;
      });
  }

  /// Animate the loading ticker.
  const startLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimation.style.display = "inherit";
    const loadingAnimationFrames = ['-', '\\', '|', '/'];
    let currentFrame = 0;

    const animate = () => {
      loadingAnimation.textContent = loadingAnimationFrames[currentFrame];
      currentFrame = (currentFrame + 1) % loadingAnimationFrames.length;
      loadingAnimationIntervals[loadingAnimationId] = setTimeout(animate, loadingAnimationPace);
    }

    animate();
  }

  /// Stop animating the loading ticker.
  const stopLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimationIntervals[loadingAnimationId] = clearTimeout(loadingAnimationIntervals[loadingAnimationId]);
    loadingAnimation.style.display = "none";
  }

  // Re-decorate the form depending on if the provided content has already been recorded onchain, and if it's sold out.
  const decorateAndShowForm = async (itemId, encodedIPFSUri) => {
    // Get references to the form state.
    const postFormStateChain = document.getElementById("post-form-state-chain");
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const postFormStateNftCategory = document.getElementById("post-form-state-nft-category");
    const postFormStateChainInput = document.getElementById("post-form-state-chain-input");
    const postFormStateProjectIdInput = document.getElementById("post-form-state-project-id-input");
    const postFormStateNftCategoryInput = document.getElementById("post-form-state-nft-category-input");
    const postFormStateReveal = document.getElementById("post-form-state-reveal");
    const postFormStateErrorMessage = document.getElementById("post-form-state-error-message");
    const postFormStateButton = document.getElementById("post-form-state-button");
    const postFormErrorMessage = document.getElementById("post-form-error-message");
    const postFormButton = document.getElementById("post-form-button");

    // Get references to the two possible forms.
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");

    const updateFormState = async () => {
      // Get a reference to the chain, project ID, and category fields.
      const chain = postFormStateChain.innerHTML;
      const projectId = parseInt(postFormStateProjectId.innerHTML);
      const category = parseInt(postFormStateNftCategory.innerHTML);

      // Set the project ID href.
      postFormStateProjectId.setAttribute('href', `${projectLinkBase(chain)}${postFormStateProjectId.innerHTML}`);

      // Look in the cache for tiers within the project ID.
      const projectIdTiers = tiersCache[projectId];

      // If there's no cache for the project ID, set it to an empty object.
      if (!projectIdTiers) tiersCache[projectId] = {};

      // Look in the cache for a tier for the project ID and encodedIPFSUri.
      let tier = tiersCache[projectId][encodedIPFSUri];
        
      // If nothing is cached, load from the contract.
      if (!tier) {

        // Check to see if there's a tier for this content.
        [tier] = await tx_view_tiers(projectId, [encodedIPFSUri], resolveChainId(chain));
        
        // If no tier, don't show the form. 
        if (!tier) {
          // Show the error message.
          postFormErrorMessage.innerHTML = "Browser not connected to the right blockchain.";
          postFormErrorMessage.style.display = "block";
          // Hide the forms.
          recordPostForm.style.display = "none";
          collectPostForm.style.display = "none";
          // Disable the button.
          postFormButton.disabled = true;
          return;
        }

        // Cache the value.
        tiersCache[projectId][encodedIPFSUri] = tier;
      }
      console.log({  tier });


      // Get a reference to the tier's ID.
      const formattedTierId = parseInt(tier[0].toString());

      // If there is no tier, the form's state is in RECORD mode, meaning the content must be recorded onchain before it can be collected.
      if (formattedTierId != 0) {
        // The form's state is in COLLECT mode, meaning new editions can be minted from an already-recorded NFT tier.

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());

        // If there's no remaining supply, the form's state is in SOLD_OUT mode, meaning it can't be minted anymore.
        if (formattedRemainingSupply == 0) {
          // Show the error message.
          postFormErrorMessage.innerHTML = "This NFT is sold out";
          postFormErrorMessage.style.display = "block";
          // Hide the forms.
          recordPostForm.style.display = "none";
          collectPostForm.style.display = "none";
          // Disable the button.
          postFormButton.disabled = true;
          return;
        }

        // Show the COLLECT form.
        collectPostForm.style.display = "block";
        // Hide the RECORD form.
        recordPostForm.style.display = "none";
        // Hide the error message.
        postFormErrorMessage.style.display = "none";

        // Get a reference to the tier's price.
        const formattedPrice = ethers.formatEther(tier[1]);

        // Show the form.
        await decorateCollectForm(chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice);
      } else {
        // Check to see if the project and category allow posting.

        // Look in the cache for allowances within the project ID.
        const projectIdAllowances = allowanceCache[projectId];

        // If there's no cache for the project ID, set it to an empty object.
        if (!projectIdAllowances) allowanceCache[projectId] = {};

        // Look in the cache for an allowance for the category within the allowances for the project ID.
        let allowance = allowanceCache[projectId][category];

        // If nothing is cached, load from the contract.
        if (!allowance) {
          // Get the allowance.
          allowance = await tx_view_allowance(projectId, category, resolveChainId(chain));

          // Cache the value.
          allowanceCache[projectId][category] = allowance;
        }

        // Get a reference to the allowance min total supply.
        const formattedMinTotalSupply = parseInt(allowance[1].toString());

        // Show an error message if there's no allowance set.
        if (formattedMinTotalSupply == 0) {
          // Show the error message.
          postFormErrorMessage.innerHTML = `Project ${projectId} isn't accepting posts on category ${category} yet.`;
          postFormErrorMessage.style.display = "block";
          // Hide forms.
          recordPostForm.style.display = "none";
          collectPostForm.style.display = "none";
          // Disable the button.
          postFormButton.disabled = true;
          return;
        }

        // Show the RECORD form.
        recordPostForm.style.display = "block";
        // Hide the COLLECT form.
        collectPostForm.style.display = "none";
        // Hide the error message.
        postFormErrorMessage.style.display = "none";

        // Get a reference to the allowance min price.
        const formattedMinPrice = ethers.formatEther(allowance[0]);

        // Get a reference to the allowance max total supply.
        const formattedMaxTotalSupply = parseInt(allowance[2].toString());

        // Get a reference to the allowance max total supply.
        const formattedAllowedAddresses = allowance[3];

        await decorateRecordForm(chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses);
      }
    }
    
    // Populate the state input values when opened.
    postFormStateReveal.addEventListener("toggle", () => {
      if (!this.open) return;
      postFormStateChainInput.selectedIndex = resolveChainSelectIndex(postFormStateChain.innerHTML);
      postFormStateProjectIdInput.value = postFormStateProjectId.innerHTML;
      postFormStateNftCategoryInput.value = postFormStateNftCategory.innerHTML;
    });

    // Change the project ID input on network change to the default.
    postFormStateChainInput.addEventListener("change", () => {
      postFormStateProjectIdInput.value = cpnProjectId(postFormStateChainInput.value);
    });

    // Submit the state change form.
    postFormStateButton.onclick = async () => {
      // Check for empty values.
      if (postFormStateProjectIdInput.value == "" || postFormStateNftCategoryInput.value == "") {
        postFormStateErrorMessage.innerHTML = "Fill out the form.";
        postFormStateErrorMessage.style.display = "block";
        return;
      } else {
        postFormStateErrorMessage.style.display = "none";
      }
      
      // Reload the mint state if the chain changed.
      if (postFormStateChain.innerHTML != postFormStateChainInput.value) {
        // Reload the state.
        await loadFrameState();

        postFormStateChain.innerHTML = postFormStateChainInput.value; 
      }

      postFormStateProjectId.innerHTML = postFormStateProjectIdInput.value;
      postFormStateProjectId.setAttribute('href', `${projectLinkBase(postFormStateChain.innerHTML)}${postFormStateProjectId.innerHTML}`);
      postFormStateNftCategory.innerHTML = postFormStateNftCategoryInput.value; 

      // Close the state change form.
      postFormStateReveal.open = false;

      // Show the loading animation.
      startLoadingAnimation('post-form-modal-loading-animation');

      // Update the form's state.
      await updateFormState();

      // Show the loading animation.
      stopLoadingAnimation('post-form-modal-loading-animation');
    }
    
    updateFormState();
  }

  const decorateRecordForm = async (chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses) => {
    // Get references to record form elements that need decorating.
    const recordPostFormBeneficiaryInput = document.getElementById("record-post-form-beneficiary-input");
    const recordPostFormCpnBeneficiaryInput = document.getElementById("record-post-form-cpn-beneficiary-input");
    const recordPostFormTotalSupplyInput = document.getElementById("record-post-form-total-supply-input");
    const recordPostFormPriceInput = document.getElementById("record-post-form-price-input");
    const recordPostFormQuantityInput = document.getElementById("record-post-form-quantity-input");
    const recordPostFormOptionsReveal = document.getElementById("record-post-form-options-reveal");
    const recordPostFormDisclaimerReveal = document.getElementById("record-post-form-disclaimer-reveal");
    const postFormErrorMessage = document.getElementById("post-form-error-message");
    const postFormButtonText = document.getElementById("post-form-button-text");
    const postFormButton = document.getElementById("post-form-button");

    // Change the button text.
    postFormButtonText.innerHTML = "record & collect";

    // Toggle off the sections.
    recordPostFormOptionsReveal.open = false;
    recordPostFormDisclaimerReveal.open = false;

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error message if not allowed.
      if (signer && formattedAllowedAddresses.length && !formattedAllowedAddresses.includes(signer)) {
        postFormErrorMessage.innerHTML = `Project ${projectId} has reserved posting to category ${category} for these addresses: ${formattedAllowedAddresses}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      // Set error messages if the currently inputted values are too small.
      } else if (recordPostFormPriceInput.value < formattedMinPrice || recordPostFormTotalSupplyInput.value < formattedMinTotalSupply || recordPostFormTotalSupplyInput.value > formattedMaxTotalSupply) {
        postFormErrorMessage.innerHTML = `Project ${projectId} has a minimum price of <span class="ether">Ξ</span>${formattedMinPrice}, a minimum total supply of ${formattedMinTotalSupply}, and a maximum total supply of ${formattedMaxTotalSupply} to record on category ${category}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else if (recordPostFormQuantityInput.value > recordPostFormTotalSupplyInput.value) {
        postFormErrorMessage.innerHTML = `The total supply is ${recordPostFormTotalSupplyInput.value}. Can't mint ${recordPostFormQuantityInput.value}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else {
        // Hide the error message.
        postFormErrorMessage.style.display = "none";
        postFormButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer; 
      const queueCheckState = async () => { 
        clearTimeout(checkStateTimer); 
        checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price, total supply, or quantity changes.
    recordPostFormPriceInput.addEventListener("input", queueCheckState);
    recordPostFormTotalSupplyInput.addEventListener("input", queueCheckState);
    recordPostFormQuantityInput.addEventListener("input", queueCheckState);

    // Set values in the form if the fields are not yet set.
    if (!recordPostFormBeneficiaryInput.value && signer) recordPostFormBeneficiaryInput.value = signer;
    if (!recordPostFormPriceInput.value) recordPostFormPriceInput.value = formattedMinPrice;
    if (!recordPostFormTotalSupplyInput.value) recordPostFormTotalSupplyInput.value = formattedMinTotalSupply;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("record-post-form-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      recordPostFormBeneficiaryInput.value = signer;
      await checkState();
    };
    
    // Submit the form.
    postFormButton.onclick = async () => {
      // Check for empty values.
      if (recordPostFormPriceInput.value == "" || recordPostFormTotalSupplyInput.value == "" || recordPostFormQuantityInput.value == "") {
        postFormErrorMessage.innerHTML = "Fill out the form.";
        postFormErrorMessage.style.display = "block";
        return;
      } 

      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');
        
      // Get the signer.
      signer = (await getSigner()).address;
      
      // Default to the signer.
      if (recordPostFormBeneficiaryInput.value == "") recordPostFormBeneficiaryInput.value = signer;
      // Default to the eth address, or the signer;
      if (recordPostFormCpnBeneficiaryInput.value == "") recordPostFormCpnBeneficiaryInput.value = defaultEthAddress || signer;

      // Make sure the form contents make sense.
      await checkState();

      if (postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            postFormErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            postFormErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('post-form-button-loading-animation');

            return;
          }
      }
      
      // Normalize values from the form.
      const totalSupply = recordPostFormTotalSupplyInput.value;
      const quantity = recordPostFormQuantityInput.value;
      const price = `${Number(recordPostFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const beneficiary = recordPostFormBeneficiaryInput.value;
      const cpnBeneficiary = recordPostFormCpnBeneficiaryInput.value;
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(projectId, category, totalSupply, price, quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));
      
          // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          postFormErrorMessage.innerHTML = "The connected network isn't supported.";
          postFormErrorMessage.style.display = "block";

          // Disable the button.
          postFormButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        postFormErrorMessage.innerHTML = e;
        postFormErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  const decorateCollectForm = async (chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice) => {
    // Get references to record form elements that need decorating.
    const collectPostFormHeader = document.getElementById("collect-post-form-header");
    const collectPostFormBeneficiaryInput = document.getElementById("collect-post-form-beneficiary-input");
    const collectPostFormCpnBeneficiaryInput = document.getElementById("collect-post-form-cpn-beneficiary-input");
    const collectPostFormQuantityInput = document.getElementById("collect-post-form-quantity-input");
    const collectPostFormPriceInput = document.getElementById("collect-post-form-price-input");
    const collectPostFormOptionsReveal = document.getElementById("collect-post-form-options-reveal");
    const collectPostFormDisclaimerReveal = document.getElementById("collect-post-form-disclaimer-reveal");
    const postFormErrorMessage = document.getElementById("post-form-error-message");
    const postFormButtonText = document.getElementById("post-form-button-text");
    const postFormButton = document.getElementById("post-form-button");

    // Toggle off the sections.
    collectPostFormOptionsReveal.open = false;
    collectPostFormDisclaimerReveal.open = false;

    // Set the header text.
    if (formattedRemainingSupply == 1) {
      collectPostFormHeader.innerHTML = `There is only 1 remaining edition of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice}.`;
    } else {
      collectPostFormHeader.innerHTML = `There are still ${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } remaining editions of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice} each.`;
    }

    // Change the button text.
    postFormButtonText.innerHTML = "collect";

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error messages if the currently inputted values are too small.
      if (collectPostFormPriceInput.value < formattedPrice) {
        postFormErrorMessage.innerHTML = `This NFT has a minimum price of <span class="ether">Ξ</span>${formattedPrice}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else if (collectPostFormQuantityInput.value > formattedRemainingSupply) {
        if (formattedRemainingSupply == 1) {
          postFormErrorMessage.innerHTML = `There is only 1 copy remaining. Can't mint ${collectPostFormQuantityInput.value}.`;
        } else {
          postFormErrorMessage.innerHTML = `There are only ${formattedRemainingSupply} copies remaining. Can't mint ${collectPostFormQuantityInput.value}.`;
        }
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else {
        // Hide the error message.
        postFormErrorMessage.style.display = "none";
        postFormButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price or quantity changes.
    collectPostFormPriceInput.addEventListener("input", queueCheckState);
    collectPostFormQuantityInput.addEventListener("input", queueCheckState);

    // Set values in the form if the fields are not yet set.
    if (!collectPostFormBeneficiaryInput.value && signer) collectPostFormBeneficiaryInput.value = signer;
    if (!collectPostFormPriceInput.value) collectPostFormPriceInput.value = formattedPrice;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("collect-post-form-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      collectPostFormBeneficiaryInput.value = signer;
      await checkState();
    };

    // Submit the form.
    postFormButton.onclick = async () => {
      // Check for empty values.
      if (collectPostFormPriceInput.value == "" || collectPostFormQuantityInput.value == "") {
        postFormErrorMessage.innerHTML = "Fill out the form.";
        postFormErrorMessage.style.display = "block";
        return;
      } 

      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Default to the signer.
      if (collectPostFormBeneficiaryInput.value == "") collectPostFormBeneficiaryInput.value = signer;
      // Default to the eth address, or the signer;
      if (collectPostFormCpnBeneficiaryInput.value == "") collectPostFormCpnBeneficiaryInput.value = defaultEthAddress || signer;

      // Make sure the form contents make sense.
      await checkState();

      if (postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');

        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
        try {
          await switchChain(expectedChainId); 
        } catch (e) {
          postFormErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
          postFormErrorMessage.style.display = "block";

          // Hide the loading animation.
          stopLoadingAnimation('post-form-button-loading-animation');

          return;
        }
      }

      // Normalize values from the form.
      const totalSupply = 1;
      const price = `${Number(collectPostFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const quantity = collectPostFormQuantityInput.value;
      const beneficiary = collectPostFormBeneficiaryInput.value;
      const cpnBeneficiary = collectPostFormCpnBeneficiaryInput.value;
      // Add a fee if the project being paid isn't the fee project ID.
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(projectId, category, totalSupply, BigInt(price), quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));
        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          postFormErrorMessage.innerHTML = "The connected network isn't supported.";
          postFormErrorMessage.style.display = "block";

          // Disable the button.
          postFormButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        postFormErrorMessage.innerHTML = e;
        postFormErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  // Get the modal set up.
  const decoratePostModal = async (itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.
    const postModal = document.getElementById("post-modal");
    const frameSubtitle = document.getElementById("frame-subtitle");
    const frameLink = document.getElementById("frame-link");
    const postFormStateReveal = document.getElementById("post-form-state-reveal");
    const postFormErrorMessage= document.getElementById("post-form-error-message");
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");

    // Track the modal in browse history.
    history.pushState({ modalOpened: true, itemId: itemId }, "", "?id=" + itemId);

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    postModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    postModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT") return;

      // If there's a video, pause it.
      if (videoSrc) modalVideo.pause();

      // Hide the RECORD form.
      recordPostForm.style.display = "none";
      // Hide the COLLECT form.
      collectPostForm.style.display = "none";
      // Hide the error message.
      postFormErrorMessage.style.display = "none";
      // Close the state reveal.
      postFormStateReveal.open = false;

      // Hide the modal.
      postModal.style.display = "none";

      toggleNavVisibility(true);

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
    });

    // Decorate the frame's title.
    const frameName = document.getElementById("frame-name");
    const frameDate = document.getElementById("frame-date");
    frameName.innerHTML = name;
    frameDate.innerHTML = `${date} | `;

    // Show and populate the frame's subtitle if there's a link.
    if (link) {
      frameSubtitle.style.display = "block";
      frameLink.innerHTML = `<a href="${link}" target="_blank">${link}</a>`;
    } else {
      frameSubtitle.style.display = "none";
    }

    // Decordate the image or video content.
    const modalImage = document.getElementById("modal-image");
    const modalVideo = document.getElementById("modal-video");
    if (videoSrc) {
      modalImage.style.display = "none"
      modalVideo.style.display = "block"
      modalVideo.autoplay = true;
      modalVideo.loop = true;
      modalVideo.muted = true;
      modalVideo.controls = true;
      modalImage.src = "";
      modalVideo.src = videoSrc;
      modalVideo.addEventListener("click", (e) => e.stopPropagation());
    } else {
      modalImage.style.display = "block"
      modalVideo.style.display = "none"
      modalVideo.src = "";
      modalImage.src = imageSrc;
      modalImage.addEventListener("click", (e) => e.stopPropagation());
    }

    // Show the loading animation.
    startLoadingAnimation('post-form-modal-loading-animation');

    // Show the form.
    await decorateAndShowForm(itemId, encodedIPFSUri);

    // Hide the loading animation.
    stopLoadingAnimation('post-form-modal-loading-animation');
  }
    
  const encodeIPFSUriFrom = async (itemId) => {
    // Create the content's encoded IPFS URL.
    const cidUrl = `{{ assets_prefix }}${itemId}/nft.json.cid.txt`;
    const cid = await (await fetch(cidUrl)).text();
    return cid ? encodeIPFSUri(cid) : "";
  }

  const decorateFrame = (frame, itemId, imageSrc, date, name, link, videoSrc) => {
    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "✃";

    const postModal = document.getElementById("post-modal");
      
    // Get references to frame elements that need decorating.
    const cta = frame.querySelector('.image-cta');;
    const title = frame.querySelector('div.image-title');
    const img = frame.querySelector('img');

    // Set the frame and img's ID.
    frame.id = 'frame-' + itemId;
    img.id = 'img-' + itemId;

    // Set the content.
    cta.textContent = '[rec]';
    title.innerHTML = `<span><span class="image-date">${date} | </span>${ name }<span>`;

    // Mark videos with an icon.
    if (videoSrc) {
      const overlay = document.createElement("div");
      overlay.classList.add("overlay-icon");
      overlay.classList.add("video-icon");
      frame.appendChild(overlay);
    }

    // Summon a modal when the frame is clicked.
    frame.addEventListener("click", async (e) => {
      e.preventDefault();

      // Show the modal.
      postModal.style.display = "block";

      toggleNavVisibility(true);

      // Make the modal look right.
      await decoratePostModal(itemId, await encodeIPFSUriFrom(itemId), name, date, link, imageSrc, videoSrc);
    });
  }

  /// Load the frame contents.
  const loadFrame = async (frame) => {
    const img = frame.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }

      checkForDimensions();
    });
  }

  /// Get the top.
  const getTopTarget = (frame, row) => {
    if (row == 1) {
      const frames = document.getElementById("frames");
      return frames.offsetTop;
    } 

    let previousRow = rows[row - 2];
    let candidateFrame;

    for (let j = 0; j < previousRow.frames.length; j++) {
      let frameToCheck = previousRow.frames[j];

      if (
        frame.left < frameToCheck.right + horizontalMargin &&
        frame.right + horizontalMargin > frameToCheck.left &&
        (candidateFrame == null || frameToCheck.bottom > candidateFrame.bottom)
      ) candidateFrame = frameToCheck;
      else if (frame.right <= frameToCheck.left) {
        return candidateFrame ? candidateFrame.bottom : getTopTarget(frame, row - 1);
      }
    }
    
    if (!candidateFrame) {
      console.log({ frame, row, previousRow });
    }
    return candidateFrame.bottom;
  }

  const frameImage = (src) => {
    const frames = document.getElementById("frames");
    const frame = document.createElement("div");
    const header = document.createElement("div");
    const footer = document.createElement("div");
    const title = document.createElement("div");
    const img = document.createElement("img");
    const cta = document.createElement("div");

    frame.classList.add("frame");
    frame.style.transitionProperty = "opacity, margin-top";
    frame.style.transitionDuration = `${transitionDuration / 1000}s, ${transitionDuration / 1000}s`;
    frame.style.transitionTimingFunction = "ease, ease";
    header.classList.add("image-header");
    footer.classList.add("image-footer");
    cta.classList.add("image-cta");
    title.classList.add("image-title");
    img.loading = "lazy";
    img.style.cursor = "pointer";

    // Get random width.
    const widthClass = widthClasses[Math.floor(Math.random() * widthClasses.length)];
    frame.classList.add(widthClass);

    img.src = src;

    header.appendChild(cta);
    header.appendChild(title);
    frame.appendChild(header);
    frame.appendChild(img);
    frames.appendChild(frame);

    return frame;
  }

  const positionAndShowFrame = async (imageFrame) => {
    await loadFrame(imageFrame);

    if (loadingAnimationIntervals['main-loading-animation']) stopLoadingAnimation('main-loading-animation');

    const rect = imageFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;
    
    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
      let newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ frames: [newFrame] });
    else rows[rows.length - 1].frames.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = window.getComputedStyle(imageFrame).display == "block" ? 0 : heightDiff + scrollTop - verticalMargin;
    imageFrame.classList.add("frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            imageFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        imageFrame.addEventListener("transitionend", handleEvent);
        imageFrame.style.marginTop = -marginTop + "px";
      } else setTimeout(resolve, transitionDuration);
    });
  }

  const loadImageFrames = async () => {
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const itemIds = [];
    frames = data['articles']
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(item => item.hasVideo === true || item.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)))
      .map((item) => {
        items.push(item);
        // if item.hasVideo, use _videoThumbnail.png
        // else use a random attachment
        const imageName = item.hasVideo ? '_videoThumbnail.png' : item.attachments[Math.floor(Math.random() * item.attachments.length)];
        const videoName = item.hasVideo ? './' + item.id + '/' + item.videoFilename : null;
        const src = './' + item.id + '/' + imageName;
        const frame = frameImage(src);
        itemIds.push(item.id);
        decorateFrame(frame, item.id, src, formatTimestamp(item.created), item.title, item.externalLink, videoName);
        return frame;
      }
    );

    // if there is ?id= in the url, open the modal
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    if (id) {
      item = items.find(item => item.id == id);
      if (item) {
        const img = document.getElementById('img-' + item.id);
          if (img) setTimeout(() => img.click(), 200);
      }
    }

    encodedIPFSUris = await Promise.all(itemIds.map(async (itemId) => await encodeIPFSUriFrom(itemId)));

    const positionAndShowFrames = async () => {
      for (const frame of frames)
        await positionAndShowFrame(frame);
    };

    await Promise.all([loadFrameState(), positionAndShowFrames()]);
  }

  const decorateNewJbForm = () => {
    const forkFormChainInput = document.getElementById("fork-form-state-chain-input");
    const forkFormNewJbCollectionNameInput = document.getElementById("fork-form-new-jb-collection-name-input");
    const forkFormNewJbCollectionSymbolInput = document.getElementById("fork-form-new-jb-collection-symbol-input");
    const forkFormNewJbProjectOwnerInput = document.getElementById("fork-form-new-jb-project-owner-input");
    const forkFormNewJbMinimumPriceInput = document.getElementById("fork-form-new-jb-minimum-price-input");
    const forkFormNewJbMinimumTotalSupplyInput = document.getElementById("fork-form-new-jb-minimum-total-supply-input");
    const forkFormNewJbMaximumTotalSupplyInput = document.getElementById("fork-form-new-jb-maximum-total-supply-input");
    const forkFormNewJbAddressesInput = document.getElementById("fork-form-new-jb-addresses-input");
    const forkFormNewJbErrorMessage = document.getElementById("fork-form-new-jb-error-message");
    const forkFormNewJbSubmitButton = document.getElementById("fork-form-new-jb-submit-button");

    // Set values in the form if the fields are not yet set.
    if (!forkFormNewJbProjectOwnerInput.value && signer) forkFormProjectOwnerInput.value = signer;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("fork-form-new-jb-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      forkFormNewJbProjectOwnerInput.value = signer;
    };

    // Submit the form.
    forkFormNewJbSubmitButton.onclick = async () => {
      // Check for empty values.
      if (forkFormNewJbCollectionNameInput.value == "" || forkFormNewJbCollectionSymbolInput.value == "") {
        forkFormNewJbErrorMessage.innerHTML = "Fill out the form.";
        forkFormNewJbErrorMessage.style.display = "block";
        return;
      } else {
        // Hide the error message.
        forkFormNewJbErrorMessage.style.display = "none";
      }

      // Default to max
      if (forkFormNewJbMaximumTotalSupplyInput.value == "") forkFormNewJbMaximumTotalSupplyInput.value = 1000000000;
      // Default to 1
      if (forkFormNewJbMinimumTotalSupplyInput.value == "") forkFormNewJbMinimumTotalSupplyInput.value = 1;
      // Default to free
      if (forkFormNewJbMinimumPriceInput.value == "") forkFormNewJbMinimumPriceInput.value = 0;
      // Default to the signer.
      signer = (await getSigner()).address;
      if (forkFormNewJbProjectOwnerInput.value == "") forkFormNewJbProjectOwnerInput.value = signer;

      // Show the loading animation.
      startLoadingAnimation('fork-form-new-jb-button-loading-animation');

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(forkFormChainInput.value);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormNewJbErrorMessage.innerHTML = `Browser not connected to ${forkFormChainInput.value}.`;
            forkFormNewJbErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-new-jb-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const name = forkFormNewJbCollectionNameInput.value;
      const symbol = forkFormNewJbCollectionSymbolInput.value;
      const owner = forkFormNewJbProjectOwnerInput.value;
      const minimumPrice = `${Number(forkFormNewJbMinimumPriceInput.value) * 1_000_000_000_000_000_000}`;
      const minimumTotalSupply = forkFormNewJbMinimumTotalSupplyInput.value;
      const maximumTotalSupply = forkFormNewJbMaximumTotalSupplyInput.value;
      const allowedAddresses = forkFormNewJbAddressesInput.value == "" ? [] : forkFormNewJbAddressesInput.value.split('\n');

      try {
        // Try to process the transaction.
        const accepted = await tx_deploy_project(name, symbol, owner, minimumPrice, minimumTotalSupply, maximumTotalSupply, allowedAddresses, expectedChainId);

        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormNewJbErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormNewJbErrorMessage.style.display = "block";
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-new-jb-button-loading-animation');
      } catch (e) {
        forkFormNewJbErrorMessage.innerHTML = e;
        forkFormNewJbErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-new-jb-button-loading-animation');
      }
    }
  }

  const decoratePermissionForm = () => {
    const forkFormChainInput = document.getElementById("fork-form-state-chain-input");
    const forkFormOperatorProjectIdInput = document.getElementById("fork-form-operator-project-id-input");
    const forkFormPermissionSubmitButton = document.getElementById("fork-form-permission-submit-button");
    const forkFormPermissionErrorMessage = document.getElementById("fork-form-permission-error-message");

    // Submit the form.
    forkFormPermissionSubmitButton.onclick = async () => {
      // Check for empty values.
      if (forkFormOperatorProjectIdInput.value == "") {
        forkFormPermissionErrorMessage.innerHTML = "Fill out the form.";
        forkFormPermissionErrorMessage.style.display = "block";
        return;
      } else {
        // Hide the error message.
        forkFormPermissionErrorMessage.style.display = "none";
      }

      // Show the loading animation.
      startLoadingAnimation('fork-form-permission-button-loading-animation');

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(forkFormChainInput.value);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormPermissionErrorMessage.innerHTML = `Browser not connected to ${forkFormChainInput.value}.`;
            forkFormPermissionErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-permission-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const projectId = forkFormOperatorProjectIdInput.value;

      try {
        // Try to process the transaction.
        const accepted = await tx_set_operator(projectId, expectedChainId);

        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormPermissionErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormPermissionErrorMessage.style.display = "block";
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-permission-button-loading-animation');
      } catch (e) {
        forkFormPermissionErrorMessage.innerHTML = e;
        forkFormPermissionErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-permission-button-loading-animation');
      }
    }
  }

  const decorateAllowanceForm = () => {
    const forkFormChainInput = document.getElementById("fork-form-state-chain-input");
    const forkFormAllowanceSubmitButton = document.getElementById("fork-form-allowance-submit-button");
    const forkFormAllowanceProjectIdInput = document.getElementById("fork-form-allowance-project-id-input");
    const forkFormAllowanceCategoryInput = document.getElementById("fork-form-allowance-nft-category-input");
    const forkFormAllowanceMinimumPriceInput = document.getElementById("fork-form-allowance-minimum-price-input");
    const forkFormAllowanceMinimumTotalSupplyInput = document.getElementById("fork-form-allowance-minimum-total-supply-input");
    const forkFormAllowanceMaximumTotalSupplyInput = document.getElementById("fork-form-allowance-maximum-total-supply-input");
    const forkFormAllowanceAddressesInput = document.getElementById("fork-form-allowance-addresses-input");
    const forkFormAllowanceErrorMessage = document.getElementById("fork-form-allowance-error-message");

    // Submit the form.
    forkFormAllowanceSubmitButton.onclick = async () => {
      // Check for empty values.
      if (forkFormAllowanceProjectIdInput.value == "" || forkFormAllowanceCategoryInput.value == "") {
        forkFormAllowanceErrorMessage.innerHTML = "Fill out the form.";
        forkFormAllowanceErrorMessage.style.display = "block";
        return;
      } else {
        // Hide the error message.
        forkFormAllowanceErrorMessage.style.display = "none";
      }
      // Default to max
      if (forkFormAllowanceMaximumTotalSupplyInput.value == "") forkFormAllowanceMaximumTotalSupplyInput.value = 1000000000;
      // Default to 1
      if (forkFormAllowanceMinimumTotalSupplyInput.value == "") forkFormAllowanceMinimumTotalSupplyInput.value = 1;
      // Default to free
      if (forkFormAllowanceMinimumPriceInput.value == "") forkFormAllowanceMinimumPriceInput.value = 0;

      // Show the loading animation.
      startLoadingAnimation('fork-form-allowance-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(forkFormChainInput.value);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormAllowanceErrorMessage.innerHTML = `Browser not connected to ${forkFormChainInput.value}.`;
            forkFormAllowanceErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-allowance-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const projectId = forkFormAllowanceProjectIdInput.value;
      const category = forkFormAllowanceCategoryInput.value;
      const minimumPrice = `${Number(forkFormAllowanceMinimumPriceInput.value) * 1_000_000_000_000_000_000}`;
      const minimumTotalSupply = forkFormAllowanceMinimumTotalSupplyInput.value;
      const maximumTotalSupply = forkFormAllowanceMaximumTotalSupplyInput.value;
      const allowedAddresses = forkFormAllowanceAddressesInput.value == "" ? [] : forkFormAllowanceAddressesInput.value.split('\n');

      try {
        // Try to process the transaction.
        const accepted = await tx_configure(projectId, category, minimumPrice, minimumTotalSupply, maximumTotalSupply, allowedAddresses, expectedChainId);

        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormAllowanceErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormAllowanceErrorMessage.style.display = "block";
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-allowance-button-loading-animation');
      } catch (e) {
        forkFormAllowanceErrorMessage.innerHTML = e;
        forkFormAllowanceErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-allowance-button-loading-animation');
      }
    }
  }

  // Get the fork modal set up.
  const decorateForkModal = () => {
    // Get references to elements that need decorating.
    const forkModal = document.getElementById("fork-modal");

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    forkModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    forkModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;
        
      // Ignore if the clicked view comes while an input, select, or textarea field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT" || activeElementOnClose.tagName === "TEXTAREA") return;

      // Hide the modal.
      forkModal.style.display = "none";

      toggleNavVisibility(true);
    });
        
    decorateNewJbForm();
    decoratePermissionForm();
    decorateAllowanceForm();
  }

  const setupForking = () => {
    const forkModal = document.getElementById("fork-modal");
    const fork = document.getElementById("fork");

    fork.addEventListener("click", async (e) => {
      e.preventDefault();
     
      // Show the modal.
      forkModal.style.display = "block";

      toggleNavVisibility(true);

      // Make the modal look right.
      await decorateForkModal();
    });
  }
  
  const toggleNavVisibility = (force) => {
    const navContainer = document.getElementById('nav-container');
    const postModal = document.getElementById('post-modal');
    const forkModal = document.getElementById('fork-modal');
    const top = document.getElementById('top');

    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
    const maxScrollTop = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    
    if (force || lastScrollTop > noZcrollEffectEdgeDistance && maxScrollTop - lastScrollTop > noZcrollEffectEdgeDistance) {
      if (currentScrollTop > lastScrollTop || postModal.style.display == "block" || forkModal.style.display == "block") {
        navContainer.style.visibility = "hidden";
        navContainer.style.opacity = 0;
        delete navContainer.style.transitionDelay;
        navContainer.style.transitionDelay = "0s";
        top.style.borderBottom = window.getComputedStyle(navContainer).borderBottom;
        navContainer.classList.add('hidden');
      } else {
        navContainer.style.visibility = "visible";
        navContainer.style.opacity = 1;
        top.style.borderBottom = "none";
        navContainer.classList.remove('hidden');
      }
    }

    lastScrollTop = currentScrollTop;
  }
  
  const adjustTopPadding = () => {
    const top = document.getElementById('top');
    const topDom = document.getElementById('top-dom');
    const framesDom = document.getElementById('frames-dom');
    const postModal = document.getElementById('post-modal');
    const forkModal = document.getElementById('fork-modal');

    const topDomHeight = topDom.offsetHeight;
    const topHeight = top.offsetHeight;

    framesDom.style.paddingTop = topDomHeight + 'px';
    postModal.style.top = topHeight + 'px';
    forkModal.style.top = topHeight + 'px';
    postModal.style.height = `calc(100% - ${topHeight}px)`;
    forkModal.style.height = `calc(100% - ${topHeight}px)`;
  }

  window.addEventListener("load", adjustTopPadding);
  window.addEventListener("resize", adjustTopPadding);

  let isFirstScrollEvent = true;
  window.addEventListener("scroll", () => {
    if (isFirstScrollEvent) {
        isFirstScrollEvent = false; 
        return;
    }

    toggleNavVisibility(false);
  });

  fetchSettings();
  loadImageFrames();
  startLoadingAnimation('main-loading-animation');
  setupForking();
</script>
{% endblock %}
