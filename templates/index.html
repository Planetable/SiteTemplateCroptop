{% extends 'base.html' %}

{% block head %}
{% include 'modules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const modal = document.getElementById("modal");
    modal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div class="top">
  {% if has_avatar == true %}
  <img src="{{ assets_prefix }}avatar.png" width="72" height="72" class="avatar">
  {% endif %}
  <div class="site-info">
    <div class="site-title">{{ page_title|escape }}</div>
    {% if page_description_html.count > 0 %}<div class="site-about">{{ page_description_html }}</div>{% endif %}
  </div>
  <div class="site-detail">
      <span><a href="https://croptop.eth.limo" target="_blank">source</a></span>
  </div>
  {% include 'modules/social_icons.html' %}
</div>
{% include 'modules/nav.html' %}
<div id="loading-animation"></div>
<div id="frames"></div>
<div id="modal" class="closes-modal">
  <div id="modal-content" class="closes-modal">
    <div id="modal-header" class="closes-modal">
      <span id="frame-date"></span><span id="frame-name"></span>
      <div id="modal-subtitle" class="closes-modal">
          <span id="frame-link"></span>
      </div>
      <div id="form-state" class="closes-modal">
        <details id="form-state-reveal">
          <summary id="form-state-toggle" class="toggle"></summary>
          <div class="form-section-description">Specify the Juicebox project that is being funded from this NFT sale and the category under which it will appear. Changing these values will change the availability of this NFT.</div>
          <div class="form-section">
            <div class="form-item" style="flex: 1;">
              <div class="form-label">Project ID</div>
              <div class="form-value"><input type="text" value="758" id="form-state-project-id-input"></div>
            </div>
            <div class="form-item" style="flex: 1;">
              <div class="form-label">NFT category ID</div>
              <div class="form-value"><input type="text" value="0" id="form-state-nft-category-input"></div>
            </div>
          </div>
          <button id="form-state-button" class="form-button">[<span id="form-state-button-text" class="form-button-text">update</span>]</button>
         </details>
         <div id="form-state-item">Project ID: <span id="form-state-project-id" class="form-state-item-value"></span>, NFT category ID <span id="form-state-nft-category" class="form-state-item-value"></span></div>
      </div>
    </div>
    <div id="collect-form" class="form closes-modal">
      <span id="collect-form-header" class="form-header"></span>
      <div class="form-body">
        <details id="collect-form-options-reveal">
          <summary id="collect-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Determine the price you want to pay and the address that will be sent the copy you are paying for.</div>
          <div class="form-section">
            <div class="form-item" style="flex: 1;">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="text" value="" id="collect-form-price-input">
              </div>
            </div>
            <div class="form-item" style="flex: 2;">
              <div class="form-label">Address <button id="collect-form-load-address-button" class="load-address-button">[<span id="collect-form-load-address-button-text" class="load-address-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="collect-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
            <details id="collect-form-disclaimer-reveal">
              <summary id="collect-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary.</summary>
              <div class="form-section">
                <div class="form-item" style="flex: 1;">
                  <div class="form-label">$CPN Beneficiary Address</div>
                  <div class="form-value">
                    <input type="text" placeholder="Defaults to the address of this site's author" id="collect-form-cpn-beneficiary-input">
                  </div>
                </div>
              </div>
          </details>
      </div>
    </div>
    <div id="record-form" class="form closes-modal">
      <span class="form-header">This file isn't yet onchain. Record it onchain to collect a first copy.</span>
      <div class="form-body">
        <details id="record-form-options-reveal">
          <summary id="record-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Set the NFT's price, how many editions of this NFT will be made available for collecting, and the address that will be sent its first copy that you are paying for.</div>
          <div class="form-section">
            <div class="form-item" style="flex: 1;">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="text" value="" id="record-form-price-input">
              </div>
            </div>
            <div class="form-item" style="flex: 1;">
              <div class="form-label">Total supply</div>
              <div class="form-value">
                <input type="number" placeholder="10" value="" id="record-form-total-supply-input">
              </div>
            </div>
            <div class="form-item" style="flex: 2;">
              <div class="form-label">Address <button id="record-form-load-address-button" class="load-address-button">[<span id="record-form-load-address-button-text" class="load-addres-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="record-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
            <details id="record-form-disclaimer-reveal">
              <summary id="record-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary.</summary>
              <div class="form-section">
                <div class="form-item" style="flex: 1;">
                  <div class="form-label">$CPN Beneficiary Address</div>
                  <div class="form-value">
                    <input type="text" placeholder="Defaults to the address of this site's author" id="record-form-cpn-beneficiary-input">
                  </div>
                </div>
              </div>
          </details>
      </div>
    </div>
    <div id="form-error-message"></div>
    <button id="form-submit-button" class="form-button">[<span id="form-submit-button-text">collect</span>]</button>
    <img id="modal-image"></img>
    <video id="modal-video"></video>
  </div>
</div>
<script>
  // Layout constants.
  const frames = document.getElementById("frames");
  const horizontalMargin = 24;
  const verticalMargin = 10;
  const transitionDuration = 300;
  const widthClasses = ["w1", "w2", "w3"];
  const loadingAnimationPace = 100;
  const formInputReactionTimeDelay = 1000;

  // State constants.
  const allowanceCache = {};
  const tiersCache = {};

  // Layout variables.
  let items = Array();
  let loadingAnimationInterval;
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];

  // State variables.
  let defaultProjectId = 758;
  let defaultNftCategory = 0;
  let defaultEthAddress;
  let formState;
  
  /// Get admin settings.
  const fetchSettings = () => {
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");
    
    formStateProjectId.innerHTML = defaultProjectId;
    formStateNftCategory.innerHTML = defaultNftCategory;

    fetch("{{ assets_prefix }}templateSettings.json")
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        if (data.juiceboxProjectID != null) formStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        if (data.nftCategory != null) formStateNftCategory.innerHTML = Number(data.nftCategory);
        if (data.ethAddress) defaultEthAddress = data.ethAddress;
      });
  }
  
  /// Animate the loading ticker.
  const startLoadingAnimation = () => {
    const loadingAnimation = document.getElementById('loading-animation');
    const loadingAnimationFrames = ['-', '\\', '|', '/'];
    let currentFrame = 0;

    const animate = () => {
      loadingAnimation.textContent = loadingAnimationFrames[currentFrame];
      currentFrame = (currentFrame + 1) % loadingAnimationFrames.length;
      loadingAnimationInterval = setTimeout(animate, loadingAnimationPace);
    }

    animate();
  }
  
  /// Stop animating the loading ticker.
  const stopLoadingAnimation = () => {
    const loadingAnimation = document.getElementById('loading-animation');
    loadingAnimationInterval = clearTimeout(loadingAnimationInterval);
    loadingAnimation.style.display = "none";
  }
  
  // Re-decorate the form depending on if the provided content has already been recorded onchain, and if it's sold out.
  const decorateAndShowForm = async (itemId) => {
    // Get references to the form state.
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");
    const formStateButton = document.getElementById("form-state-button");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButton = document.getElementById("form-submit-button");

    // Get references to the two possible forms.
    const recordForm = document.getElementById("record-form");
    const collectForm = document.getElementById("collect-form");

    // Create the content's encoded IPFS URL.
    const cidUrl = `{{ assets_prefix }}${itemId}/nft.json.cid.txt`;
    const cid = await (await fetch(cidUrl)).text();
    const encodedIPFSUri = cid ? encodeIPFSUri(cid) : "";

    const updateFormState = async () => {
      // Get a reference to the project ID field.
      const projectId = formStateProjectId.innerHTML;
      const category = formStateNftCategory.innerHTML;

      // Look in the cache for tiers within the project ID.
      const projectIdTiers = tiersCache[projectId];
      
      // If there's no cache for the project ID, set it to an empty object.
      if (!projectIdTiers) tiersCache[projectId] = {};

      // Look in the cache for a tier for the project ID and encodedIPFSUri.
      let tier = tiersCache[projectId][encodedIPFSUri]; 
      
      // If nothing is cached, load from the contract.
      if (!tier) {
        // Check to see if there's a tier for this content.
        [tier] = await tx_view_tier(projectId, encodedIPFSUri);

        // Cache the value.
        tiersCache[projectId][encodedIPFSUri] = tier;
      }
            
      // Get a reference to the tier's ID.
      const formattedTierId = parseInt(tier[0].toString());
            
      // If there is no tier, the form's state is in RECORD mode, meaning the content must be recorded onchain before it can be collected.
      if (formattedTierId != 0) {
        // The form's state is in COLLECT mode, meaning new editions can be minted from an already-recorded NFT tier.    

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());

        // If there's no remaining supply, the form's state is in SOLD_OUT mode, meaning it can't be minted anymore.
        if (formattedRemainingSupply == 0) {
          // Show the error message.
          formErrorMessage.innerHTML = "This NFT is sold out";
          formErrorMessage.style.display = "block"; 
          // Hide the forms.
          recordForm.style.display = "none";
          collectForm.style.display = "none";
          // Disable the button.
          formSubmitButton.disabled = true;
          return;
        }
        
        // Show the COLLECT form.
        collectForm.style.display = "block";
        // Hide the RECORD form.
        recordForm.style.display = "none";
        // Hide the error message.
        formErrorMessage.style.display = "none"; 
          
        // Get a reference to the tier's price.
        const formattedPrice = ethers.formatEther(tier[1]);
        
        // Show the form.
        await decorateCollectForm(projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice);
      } else {
        // Check to see if the project and category allow posting.
    
        // Look in the cache for allowances within the project ID.
        const projectIdAllowances = allowanceCache[projectId];
      
        // If there's no cache for the project ID, set it to an empty object.
        if (!projectIdAllowances) allowanceCache[projectId] = {};
      
        // Look in the cache for an allowance for the category within the allowances for the project ID.
        let allowance = allowanceCache[projectId][category]; 
      
        // If nothing is cached, load from the contract.
        if (!allowance) {
          // Get the allowance.
          allowance = await tx_view_allowance(projectId, category);

          // Cache the value.
          allowanceCache[projectId][category] = allowance;
        }
      
        // Get a reference to the allowance min total supply.
        const formattedMinTotalSupply = parseInt(allowance[1].toString());

        // Show an error message if there's no allowance set.
        if (formattedMinTotalSupply == 0) {
          // Show the error message.
          formErrorMessage.innerHTML = `Project ${projectId} isn't accepting posts on category ${category}.`;
          formErrorMessage.style.display = "block"; 
          // Hide forms.
          recordForm.style.display = "none";
          collectForm.style.display = "none";
          // Disable the button.
          formSubmitButton.disabled = true;
        } 

        // Show the RECORD form.
        recordForm.style.display = "block";
        // Hide the COLLECT form.
        collectForm.style.display = "none";
        // Hide the error message.
        formErrorMessage.style.display = "none"; 

        // Get a reference to the allowance min price.
        const formattedMinPrice = ethers.formatEther(allowance[0]);

        await decorateRecordForm(projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMinPrice);
      }
    }

    // Submit the state change form.
    formStateButton.onclick = async () => {
      // Get the state values from the form fields.
      const formStateProjectIdInput = document.getElementById("form-state-project-id-input");
      const formStateNftCategoryInput = document.getElementById("form-state-nft-category-input");
      const formStateReveal = document.getElementById("form-state-reveal");

      // Set the state.
      formStateProjectId.innerHTML = formStateProjectIdInput.value;
      formStateNftCategory.innerHTML = formStateNftCategoryInput.value;

      // Close the state change form.
      formStateReveal.open = false;

      // Update the form's state.
      updateFormState();
    }  

    updateFormState();
  }

  const decorateRecordForm = (projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMinPrice) => {
    // Get references to record form elements that need decorating.    
    const recordFormBeneficiaryInput = document.getElementById("record-form-beneficiary-input");
    const recordFormCpnBeneficiaryInput = document.getElementById("record-form-cpn-beneficiary-input");
    const recordFormTotalSupplyInput = document.getElementById("record-form-total-supply-input");
    const recordFormPriceInput = document.getElementById("record-form-price-input");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButtonText = document.getElementById("form-submit-button-text");
    const formSubmitButton = document.getElementById("form-submit-button");
    const recordFormOptionsReveal = document.getElementById('record-form-options-reveal');
    const recordFormDisclaimerReveal = document.getElementById('record-form-disclaimer-reveal');
    
    // Toggle off the sections.
    recordFormOptionsReveal.open = false;
    recordFormDisclaimerReveal.open = false;
    
    // Change the button text.
    formSubmitButtonText.innerHTML = "record & collect";
    
    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("record-form-load-address-button");
    loadAddressButton.onclick = async () => {
      recordFormBeneficiaryInput.value = (await getSigner()).address;
    };
    
    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Show an error message if there's no allowance set.
      // Set allowance values in the form if the fields are not yet set.
      if (!recordFormPriceInput.value) recordFormPriceInput.value = formattedMinPrice; 
      if (!recordFormTotalSupplyInput.value) recordFormTotalSupplyInput.value = formattedMinTotalSupply; 
            
      // Set error messages if the currently inputted values are too small.
      if (recordFormPriceInput.value < formattedMinPrice || recordFormTotalSupplyInput.value < formattedMinTotalSupply) {
        formErrorMessage.innerHTML = `Project ${projectId} has a minimum price of <span class="ether">Ξ</span>${formattedMinPrice} and total supply of ${formattedMinTotalSupply} to record on category ${category}.`;
        formErrorMessage.style.display = "block"; 
        formSubmitButton.disabled = true;
      } else {
        // Hide the error message.
        formErrorMessage.style.display = "none"; 
        formSubmitButton.disabled = false;
      }
    }
      
    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);  
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the category, price, or total supply change.
    recordFormPriceInput.addEventListener('input', queueCheckState);
    recordFormTotalSupplyInput.addEventListener('input', queueCheckState);
    
    // Check the state.
    checkState();
      
    // Submit the form.
    formSubmitButton.onclick = async () => {
      await checkState();
      if (formSubmitButton.disabled) return;
      const totalSupply = recordFormTotalSupplyInput.value;
      const price = `${Number(recordFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const beneficiary = recordFormBeneficiaryInput.value;
      const cpnBeneficiary = recordFormCpnBeneficiaryInput.value;
      return await tx_collect(projectId, category, totalSupply, price, encodedIPFSUri, beneficiary, cpnBeneficiary);
    }  
  };

  const decorateCollectForm = (projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice) => {
    // Get references to record form elements that need decorating.    
    const collectFormHeader = document.getElementById("collect-form-header");
    const collectFormBeneficiaryInput = document.getElementById("collect-form-beneficiary-input");
    const collectFormCpnBeneficiaryInput = document.getElementById("collect-form-cpn-beneficiary-input");
    const collectFormPriceInput = document.getElementById("collect-form-price-input");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButtonText = document.getElementById("form-submit-button-text");
    const formSubmitButton = document.getElementById("form-submit-button");
    const collectFormOptionsReveal = document.getElementById('collect-form-options-reveal');
    const collectFormDisclaimerReveal = document.getElementById('collect-form-disclaimer-reveal');
    
    // Toggle off the sections.
    collectFormOptionsReveal.open = false;
    collectFormDisclaimerReveal.open = false;
    
    // Set the header text.
    if (formattedRemainingSupply == 1) {
      collectFormHeader.innerHTML = `There is only 1 edition of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice}.`; 
    } else {
      collectFormHeader.innerHTML = `There are still ${formattedRemainingSupply > 1000000 ? infinite : formattedRemainingSupply } editions of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice} each.`; 
    }

    // Change the button text.
    formSubmitButtonText.innerHTML = "collect";
    
    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("collect-form-load-address-button");
    loadAddressButton.onclick = async () => {
      collectFormBeneficiaryInput.value = (await getSigner()).address;
    };
    
    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set allowance values in the form if the fields are not yet set.
      if (!collectFormPriceInput.value) collectFormPriceInput.value = formattedPrice; 
            
      // Set error messages if the currently inputted values are too small.
      if (collectFormPriceInput.value < formattedPrice) {
        formErrorMessage.innerHTML = `This NFT has a minimum price of <span class="ether">Ξ</span>${formattedPrice}.`;
        formErrorMessage.style.display = "block"; 
        formSubmitButton.disabled = true;
      } else {
        // Hide the error message.
        formErrorMessage.style.display = "none"; 
        formSubmitButton.disabled = false;
      }
    }
      
    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);  
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price changes.
    collectFormPriceInput.addEventListener('input', queueCheckState);
    
    // Check the state.
    checkState();

    // Submit the form.
    formSubmitButton.onclick = async () => {
      await checkState();
      if (formSubmitButton.disabled) return;
      const totalSupply = 1;
      const price = `${Number(collectFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const beneficiary = collectFormBeneficiaryInput.value;
      const cpnBeneficiary = collectFormCpnBeneficiaryInput.value;
      return await tx_collect(projectId, category, totalSupply, price, encodedIPFSUri, beneficiary, cpnBeneficiary);
    }  
  };
  
  // Get the modal set up.
  const decorateModal = async (itemId, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.    
    const modal = document.getElementById("modal");
    const modalHeader = document.getElementById("modal-header");
    const modalSubtitle = document.getElementById("modal-subtitle");
    const modalContent = document.getElementById("modal-content");
    const formStateItem = document.getElementById("form-state-item"); 
    const formStateReveal = document.getElementById("form-state-reveal");
    const formErrorMessage= document.getElementById("form-error-message");
    const recordForm = document.getElementById("record-form");
    const collectForm = document.getElementById("collect-form");
    
    // Track the modal in browse history.
    history.pushState({ modalOpened: true, itemId: itemId }, "", "?id=" + itemId);
   
    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    modal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    modal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT") return;
      
      // If there's a video, pause it.
      if (videoSrc) modalVideo.pause();

      // Hide the RECORD form.
      recordForm.style.display = "none";
      // Hide the COLLECT form.
      collectForm.style.display = "none";
      // Hide the error message.
      formErrorMessage.style.display = "none"; 
      // Close the state reveal.
      formStateReveal.open = false;

      // Hide the modal.
      modal.style.display = "none";

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
    });
    
    // Decorate the frame's title.
    const frameName = document.getElementById("frame-name");
    const frameDate = document.getElementById("frame-date");
    frameName.innerHTML = name;
    frameDate.innerHTML = `${date} | `;
    
    // Show and populate the frame's subtitle if there's a link.
    if (link) {
      const frameLink = document.getElementById("frame-link");
      modalSubtitle.style.display = "block";
      frameLink.innerHTML = `<a href="${link}" target="_blank">${link}</a>`;
    } else {
      modalSubtitle.style.display = "none";
    }
    
    // Decordate the image or video content.
    const modalImage = document.getElementById("modal-image");
    const modalVideo = document.getElementById("modal-video");
    if (videoSrc) {
      modalImage.style.display = "none"
      modalVideo.style.display = "block"
      modalVideo.autoplay = true;
      modalVideo.loop = true;
      modalVideo.muted = true;
      modalVideo.controls = true;
      modalImage.src = "";
      modalVideo.src = videoSrc;
      modalVideo.addEventListener('click', (e) => e.stopPropagation());
    } else {
      modalImage.style.display = "block"
      modalVideo.style.display = "none"
      modalVideo.src = "";
      modalImage.src = imageSrc;
      modalImage.addEventListener('click', (e) => e.stopPropagation());
    }

    // Show the form.
    decorateAndShowForm(itemId);
    
    // Hide the state when the state form is open.
    formStateReveal.addEventListener('toggle', (e) => {
      formStateItem.style.display = e.target.open ? 'none' : 'flex';
    });
    
    // Toggle the state form when clicked.
    formStateItem.addEventListener('click', (e) => {
      formStateReveal.open = true;     
    });
  }
  
  const decorateFrame = async (frame, itemId, imageSrc, date, name, link, videoSrc) => {
    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "✃";
    
    // Get references to frame elements that need decorating.    
    const ctaAnchor = frame.querySelector('a');;
    const title = frame.querySelector('div.image-title');
    const img = frame.querySelector('img');

    // Set the frame and img's ID.
    frame.id = 'frame-' + itemId;
    img.id = 'img-' + itemId;
    
    // Set the content.
    ctaAnchor.textContent = '[collect]';
    title.innerHTML = `<span><span class="image-date">${date} | </span>${ name }<span>`;
    
    // Mark videos with an icon.
    if (videoSrc) {
      const overlay = document.createElement("div");
      overlay.classList.add("overlay-icon");
      overlay.classList.add("video-icon");
      frame.appendChild(overlay);
    }
    
    // Summon a modal when the frame is clicked.
    frame.addEventListener("click", async (e) => {
      e.preventDefault();

      // Make the modal look right.
      await decorateModal(itemId, name, date, link, imageSrc, videoSrc);

      // Show the modal.
      modal.style.display = "block";
    });
  }

  /// Load the frame contents.
  const loadFrame = async (frame) => {
    const img = frame.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }
      
      checkForDimensions();
    });
  };

  /// Get the top.
  const getTopTarget = (frame, row) => {
    if (row == 1) return frames.offsetTop;

    let previousRow = rows[row - 2];
    let candidateFrame;

    for (let j = 0; j < previousRow.frames.length; j++) {
      let frameToCheck = previousRow.frames[j];

      if (
        frame.left < frameToCheck.right + horizontalMargin &&
        frame.right + horizontalMargin > frameToCheck.left &&
        (candidateFrame == null || frameToCheck.bottom > candidateFrame.bottom)
      ) candidateFrame = frameToCheck;
      else if (frame.right <= frameToCheck.left) {
        return candidateFrame ? candidateFrame.bottom : getTopTarget(frame, row - 1);
      }
    }

    return candidateFrame.bottom;
  }

  const frameImage = (src) => {
    const frame = document.createElement("div");
    const header = document.createElement("div");
    const title = document.createElement("div");
    const img = document.createElement("img");
    const cta = document.createElement("div");
    const ctaAnchor = document.createElement('a');

    frame.classList.add("frame");
    frame.style.transitionProperty = "opacity, margin-top";
    frame.style.transitionDuration = `${transitionDuration / 1000}s, ${transitionDuration / 1000}s`;
    frame.style.transitionTimingFunction = "ease, ease";
    header.classList.add("image-header");
    cta.classList.add("image-cta");
    title.classList.add("image-title");
    img.loading = "lazy";
    img.style.cursor = "pointer";

    // Get random width.
    const widthClass = widthClasses[Math.floor(Math.random() * widthClasses.length)];
    header.classList.add(widthClass);
    img.classList.add(widthClass);

    img.src = src;

    cta.appendChild(ctaAnchor);
    header.appendChild(cta);
    header.appendChild(title);
    frame.appendChild(header);
    frame.appendChild(img);
    frames.appendChild(frame);

    return frame;
  };

  const positionAndShowFrame = async (imageFrame) => {
    await loadFrame(imageFrame);

    if (loadingAnimationInterval) stopLoadingAnimation();

    const rect = imageFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;
    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
      let newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ frames: [newFrame] });
    else rows[rows.length - 1].frames.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = heightDiff + scrollTop - verticalMargin;
    imageFrame.classList.add("frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            imageFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        imageFrame.addEventListener("transitionend", handleEvent);
        imageFrame.style.marginTop = -marginTop + "px";
      } else setTimeout(resolve, transitionDuration);
    });
  }

  const loadImageFrames = async () => {
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const frames = data['articles']
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(item => item.hasVideo === true || item.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)))
      .map((item) => {
        items.push(item);
        // if item.hasVideo, use _videoThumbnail.png
        // else use a random attachment
        const imageName = item.hasVideo ? '_videoThumbnail.png' : item.attachments[Math.floor(Math.random() * item.attachments.length)];
        const videoName = item.hasVideo ? './' + item.id + '/' + item.videoFilename : null;
        const src = './' + item.id + '/' + imageName;
        const frame = frameImage(src);
        decorateFrame(frame, item.id, src, formatTimestamp(item.created), item.title, item.externalLink, videoName);
        return frame;
      }
    );

    // if there is ?id= in the url, open the modal
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    if (id) {
      // TODO: find the frame and open the modal
      item = items.find(item => item.id == id);
      if (item) {
        const img = document.getElementById('img-' + item.id);
        setTimeout(() => img.click(), 200);
      }
    }

    for (const frame of frames)
      await positionAndShowFrame(frame);
  };

  fetchSettings();
  loadImageFrames();
  startLoadingAnimation();
</script>
{% endblock %}
