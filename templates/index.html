{% extends 'base.html' %}

{% block head %}
{% include 'modules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const modal = document.getElementById("modal");
    modal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div class="top">
  {% if has_avatar == true %}
  <img src="{{ assets_prefix }}avatar.png" width="72" height="72" class="avatar">
  {% endif %}
  <div class="site-info">
    <div class="site-title">{{ page_title|escape }}</div>
    {% if page_description_html.count > 0 %}<div class="site-about">{{ page_description_html }}</div>{% endif %}
  </div>
  <div class="site-detail">
      <span><a href="https://croptop.eth.limo" target="_blank">source</a></span>
  </div>
  {% include 'modules/social_icons.html' %}
</div>
{% include 'modules/nav.html' %}
<div id="main-loading-animation" class="loading-animation"></div>
<div id="frames"></div>
<div id="modal" class="closes-modal">
  <div id="modal-content" class="closes-modal">
    <div id="modal-header" class="closes-modal">
      <span id="frame-date"></span><span id="frame-name"></span>
      <div id="modal-subtitle" class="closes-modal">
          <span id="frame-link"></span>
      </div>
      <div id="form-state" class="closes-modal">
        <details id="form-state-reveal">
          <summary id="form-state-toggle" class="toggle"><span id="form-state-chain" class="form-state-item-value"></span>, project ID: <a id="form-state-project-id" class="form-state-item-value" target="_blank"></a>, NFT category ID: <span id="form-state-nft-category" class="form-state-item-value"></span></summary>
          <div class="form-section-description">Specify the Juicebox project that is being funded from this NFT sale and the category under which it will appear. Changing these values will change the availability of this NFT.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Chain</div>
              <div class="form-value form-select-value">
                <select id="form-state-chain-input" name="chain">
                  <option value="Mainnet">Mainnet</option>
                  <option value="Goerli">Goerli</option>
                  <option value="Polygon">Polygon</option>
                </select>
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value"><input type="number" value="" id="form-state-project-id-input"></div>
            </div>
            <div class="form-item">
              <div class="form-label">NFT category ID</div>
              <div class="form-value"><input type="number" value="" id="form-state-nft-category-input"></div>
            </div>
          </div>
          <button id="form-state-button" class="form-button">[<span id="form-state-button-text" class="form-button-text">update</span>]</button>
         </details>
      </div>
    </div>
    <div id="collect-form" class="form closes-modal">
      <span id="collect-form-header" class="form-header"></span>
      <div class="form-body">
        <details id="collect-form-options-reveal">
          <summary id="collect-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Determine the price you want to pay and the address that will be sent the copy you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" value="" id="collect-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="collect-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address <button id="collect-form-load-address-button" class="load-address-button">[<span id="collect-form-load-address-button-text" class="load-address-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="collect-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
            <details id="collect-form-disclaimer-reveal">
              <summary id="collect-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary.</summary>
              <div class="form-section">
                <div class="form-item form-item-large">
                  <div class="form-label">$CPN Beneficiary Address</div>
                  <div class="form-value">
                    <input type="text" placeholder="Defaults to the address of this site's author" id="collect-form-cpn-beneficiary-input">
                  </div>
                </div>
              </div>
          </details>
      </div>
    </div>
    <div id="record-form" class="form closes-modal">
      <span class="form-header">This file isn't yet onchain. Record it onchain to collect a first copy.</span>
      <div class="form-body">
        <details id="record-form-options-reveal">
          <summary id="record-form-options-toggle" class="toggle main-toggle">options</summary>
          <div class="form-section-description">Set the NFT's price, how many editions of this NFT will be made available for collecting, and the address that will be sent its first copies that you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="text" value="" id="record-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Total supply</div>
              <div class="form-value">
                <input type="number" placeholder="10" value="" id="record-form-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="record-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address <button id="record-form-load-address-button" class="load-address-button">[<span id="record-form-load-address-button-text" class="load-addres-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="record-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
            <details id="record-form-disclaimer-reveal">
              <summary id="record-form-disclaimer-toggle" class="toggle disclaimer-toggle">override $CPN beneficiary.</summary>
              <div class="form-section">
                <div class="form-item form-item-large">
                  <div class="form-label">$CPN Beneficiary Address</div>
                  <div class="form-value">
                    <input type="text" placeholder="Defaults to the address of this site's author" id="record-form-cpn-beneficiary-input">
                  </div>
                </div>
              </div>
          </details>
      </div>
    </div>
    <div id="modal-loading-animation" class="loading-animation"></div>
    <div id="form-error-message"></div>
    <button id="form-submit-button" class="form-button">[<span id="form-submit-button-text">collect</span>]<span id="button-loading-animation" class="loading-animation"></span></button> 
    <img id="modal-image"></img>
    <video id="modal-video"></video>
  </div>
</div>
<script>
  // Layout constants.
  const horizontalMargin = 24;
  const verticalMargin = 10;
  const transitionDuration = 300;
  const widthClasses = ["w1", "w2", "w3"];
  const loadingAnimationPace = 100;
  const formInputReactionTimeDelay = 600;

  // State constants.
  const feeDivisor = 20;

  // Layout variables.
  let items = Array();
  let loadingAnimationIntervals = {};
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];

  // State variables.
  let allowanceCache = {};
  let tiersCache = {};
  let defaultChain = "Goerli";  
  let defaultNftCategory = 0;
  let defaultEthAddress;
  let formState;
  let encodedIPFSUris;
    
  const resolveChainId = (value) => {
    switch (value) {
      case "Mainnet": return 1; 
      case "Goerli": return 5; 
    }
  };

  const resolveChainSelectIndex = (chain) => {
    switch (chain) {
      case "Mainnet": return 0; 
      case "Goerli": return 1; 
      case "Polygon": return 2; 
    }
  };

  const resolveChain = (chainId) => {
    switch (chainId) {
      case 1: return "Mainnet"; 
      case 5: return "Goerli"; 
    }
  };

  const cpnProjectId = (chain) => {
    switch (chain) {
      case "Mainnet":
        return 500;
      case "Goerli":
        return 758;
      case "Polygon":
        return 78;
    }
  }

  const projectLinkBase = (chain) => {
    switch (chain) {
      case "Mainnet": 
        return "https://juicebox.money/v2/p/";
      case "Goerli": 
        return "https://goerli.juicebox.money/v2/p/";
      case "Polygon": 
        return "https://beta.polygon.juicebox.money/v2/p/";
    }
  }

  /// Get admin settings.
  const fetchSettings = () => {
    const formStateChain = document.getElementById("form-state-chain");
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");

    formStateChain.innerHTML = defaultChain;
    formStateProjectId.innerHTML = cpnProjectId(defaultChain);
    formStateNftCategory.innerHTML = defaultNftCategory;

    fetch("{{ assets_prefix }}templateSettings.json")
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        if (data.chain != null) formStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        if (data.juiceboxProjectID != null) formStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        // data.juiceboxProjectIDGoerli is also available if you need it
        if (data.nftCategory != null) formStateNftCategory.innerHTML = Number(data.nftCategory);
        if (data.ethAddress) defaultEthAddress = data.ethAddress;
      });
  }

  /// Animate the loading ticker.
  const startLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimation.style.display = "inherit";
    const loadingAnimationFrames = ['-', '\\', '|', '/'];
    let currentFrame = 0;

    const animate = () => {
      loadingAnimation.textContent = loadingAnimationFrames[currentFrame];
      currentFrame = (currentFrame + 1) % loadingAnimationFrames.length;
      loadingAnimationIntervals[loadingAnimationId] = setTimeout(animate, loadingAnimationPace);
    }

    animate();
  }

  /// Stop animating the loading ticker.
  const stopLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimationIntervals[loadingAnimationId] = clearTimeout(loadingAnimationIntervals[loadingAnimationId]);
    loadingAnimation.style.display = "none";
  }

  // Re-decorate the form depending on if the provided content has already been recorded onchain, and if it's sold out.
  const decorateAndShowForm = async (itemId, encodedIPFSUri) => {
    // Get references to the form state.
    const formStateChain = document.getElementById("form-state-chain");
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");
    const formStateChainInput = document.getElementById("form-state-chain-input");
    const formStateProjectIdInput = document.getElementById("form-state-project-id-input");
    const formStateNftCategoryInput = document.getElementById("form-state-nft-category-input");
    const formStateReveal = document.getElementById("form-state-reveal");
    const formStateButton = document.getElementById("form-state-button");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButton = document.getElementById("form-submit-button");

    // Get references to the two possible forms.
    const recordForm = document.getElementById("record-form");
    const collectForm = document.getElementById("collect-form");

    const updateFormState = async () => {
      // Get a reference to the chain, project ID, and category fields.
      const chain = formStateChain.innerHTML;
      const projectId = parseInt(formStateProjectId.innerHTML);
      const category = parseInt(formStateNftCategory.innerHTML);
      
      // Set the project ID href.
      formStateProjectId.setAttribute('href', `${projectLinkBase(chain)}${formStateProjectId.innerHTML}`);

      // Look in the cache for tiers within the project ID.
      const projectIdTiers = tiersCache[projectId];

      // If there's no cache for the project ID, set it to an empty object.
      if (!projectIdTiers) tiersCache[projectId] = {};

      // Look in the cache for a tier for the project ID and encodedIPFSUri.
      let tier = tiersCache[projectId][encodedIPFSUri];

      // If nothing is cached, load from the contract.
      if (!tier) {
        // Check to see if there's a tier for this content.
        [tier] = await tx_view_tiers(projectId, [encodedIPFSUri]);

        // Cache the value.
        tiersCache[projectId][encodedIPFSUri] = tier;
      }

      // Get a reference to the tier's ID.
      const formattedTierId = parseInt(tier[0].toString());

      // If there is no tier, the form's state is in RECORD mode, meaning the content must be recorded onchain before it can be collected.
      if (formattedTierId != 0) {
        // The form's state is in COLLECT mode, meaning new editions can be minted from an already-recorded NFT tier.

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());

        // If there's no remaining supply, the form's state is in SOLD_OUT mode, meaning it can't be minted anymore.
        if (formattedRemainingSupply == 0) {
          // Show the error message.
          formErrorMessage.innerHTML = "This NFT is sold out";
          formErrorMessage.style.display = "block";
          // Hide the forms.
          recordForm.style.display = "none";
          collectForm.style.display = "none";
          // Disable the button.
          formSubmitButton.disabled = true;
          return;
        }

        // Show the COLLECT form.
        collectForm.style.display = "block";
        // Hide the RECORD form.
        recordForm.style.display = "none";
        // Hide the error message.
        formErrorMessage.style.display = "none";

        // Get a reference to the tier's price.
        const formattedPrice = ethers.formatEther(tier[1]);

        // Show the form.
        await decorateCollectForm(chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice);
      } else {
        // Check to see if the project and category allow posting.

        // Look in the cache for allowances within the project ID.
        const projectIdAllowances = allowanceCache[projectId];

        // If there's no cache for the project ID, set it to an empty object.
        if (!projectIdAllowances) allowanceCache[projectId] = {};

        // Look in the cache for an allowance for the category within the allowances for the project ID.
        let allowance = allowanceCache[projectId][category];

        // If nothing is cached, load from the contract.
        if (!allowance) {
          // Get the allowance.
          allowance = await tx_view_allowance(projectId, category);

          // Cache the value.
          allowanceCache[projectId][category] = allowance;
        }

        // Get a reference to the allowance min total supply.
        const formattedMinTotalSupply = parseInt(allowance[1].toString());

        // Get a reference to the allowance max total supply.
        // TODO
        const formattedMaxTotalSupply = 10000; //parseInt(allowance[2].toString());

        // Show an error message if there's no allowance set.
        if (formattedMinTotalSupply == 0) {
          // Show the error message.
          formErrorMessage.innerHTML = `Project ${projectId} isn't accepting posts on category ${category} yet.`;
          formErrorMessage.style.display = "block";
          // Hide forms.
          recordForm.style.display = "none";
          collectForm.style.display = "none";
          // Disable the button.
          formSubmitButton.disabled = true;
          return;
        }

        // Show the RECORD form.
        recordForm.style.display = "block";
        // Hide the COLLECT form.
        collectForm.style.display = "none";
        // Hide the error message.
        formErrorMessage.style.display = "none";

        // Get a reference to the allowance min price.
        const formattedMinPrice = ethers.formatEther(allowance[0]);

        await decorateRecordForm(chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice);
      }
    }
    
    // Populate the state input values when opened.
    formStateReveal.addEventListener("toggle", () => {
      if (!this.open) return;
      formStateChainInput.selectedIndex = resolveChainSelectIndex(formStateChain.innerHTML);
      formStateProjectIdInput.value = formStateProjectId.innerHTML;
      formStateNftCategoryInput.value = formStateNftCategory.innerHTML;
    });

    // Change the project ID input on network change to the default.
    formStateChainInput.addEventListener("change", () => {
      formStateProjectIdInput.value = cpnProjectId(formStateChainInput.value);
    });

    // Submit the state change form.
    formStateButton.onclick = async () => {
      // Get the state values from the form fields.
      const formStateChainInput = document.getElementById("form-state-chain-input");
      const formStateProjectIdInput = document.getElementById("form-state-project-id-input");
      const formStateNftCategoryInput = document.getElementById("form-state-nft-category-input");
      const formStateReveal = document.getElementById("form-state-reveal");
      
      formStateChain.innerHTML = formStateChainInput.value; 
      formStateProjectId.innerHTML = formStateProjectIdInput.value;
      formStateProjectId.setAttribute('href', `${projectLinkBase(formStateChain.innerHTML)}${formStateProjectId.innerHTML}`);
      formStateNftCategory.innerHTML = formStateNftCategoryInput.value; 

      // Close the state change form.
      formStateReveal.open = false;

      // Show the loading animation.
      startLoadingAnimation('modal-loading-animation');

      // Update the form's state.
      await updateFormState();

      // Show the loading animation.
      stopLoadingAnimation('modal-loading-animation');
    }

    updateFormState();
  }

  const decorateRecordForm = (chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice) => {
    // Get references to record form elements that need decorating.
    const recordFormBeneficiaryInput = document.getElementById("record-form-beneficiary-input");
    const recordFormCpnBeneficiaryInput = document.getElementById("record-form-cpn-beneficiary-input");
    const recordFormTotalSupplyInput = document.getElementById("record-form-total-supply-input");
    const recordFormPriceInput = document.getElementById("record-form-price-input");
    const recordFormQuantityInput = document.getElementById("record-form-quantity-input");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButtonText = document.getElementById("form-submit-button-text");
    const formSubmitButton = document.getElementById("form-submit-button");
    const recordFormOptionsReveal = document.getElementById('record-form-options-reveal');
    const recordFormDisclaimerReveal = document.getElementById('record-form-disclaimer-reveal');

    // Toggle off the sections.
    recordFormOptionsReveal.open = false;
    recordFormDisclaimerReveal.open = false;

    // Change the button text.
    formSubmitButtonText.innerHTML = "record & collect";

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("record-form-load-address-button");
    loadAddressButton.onclick = async () => {
      recordFormBeneficiaryInput.value = (await getSigner()).address;
    };

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error messages if the currently inputted values are too small.
        if (recordFormPriceInput.value < formattedMinPrice || recordFormTotalSupplyInput.value < formattedMinTotalSupply || recordFormTotalSupplyInput.value > formattedMaxTotalSupply) {
          formErrorMessage.innerHTML = `Project ${projectId} has a minimum price of <span class="ether">Ξ</span>${formattedMinPrice}, a minimum total supply of ${formattedMinTotalSupply}, and a maximum total supply of ${formattedMaxTotalSupply} to record on category ${category}.`;
        formErrorMessage.style.display = "block";
        formSubmitButton.disabled = true;
      } else if (recordFormQuantityInput.value > recordFormTotalSupplyInput.value) {
        formErrorMessage.innerHTML = `The total supply is ${recordFormTotalSupplyInput.value}. Can't mint ${recordFormQuantityInput.value}.`;
        formErrorMessage.style.display = "block";
        formSubmitButton.disabled = true;
      } else {
        // Hide the error message.
        formErrorMessage.style.display = "none";
        formSubmitButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price, total supply, or quantity changes.
    recordFormPriceInput.addEventListener('input', queueCheckState);
    recordFormTotalSupplyInput.addEventListener('input', queueCheckState);
    recordFormQuantityInput.addEventListener('input', queueCheckState);

    // Set allowance values in the form if the fields are not yet set.
    if (!recordFormPriceInput.value) recordFormPriceInput.value = formattedMinPrice;
    if (!recordFormTotalSupplyInput.value) recordFormTotalSupplyInput.value = formattedMinTotalSupply;

    // Check the state.
    checkState();

    // Submit the form.
    formSubmitButton.onclick = async () => {
      // Make sure the form contents make sense.
      await checkState();
      if (formSubmitButton.disabled) return;

      // Show the loading animation.
      startLoadingAnimation('button-loading-animation');

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            // Hide the loading animation.
            stopLoadingAnimation('button-loading-animation');

            formErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            formErrorMessage.style.display = "block";
            return;
          }
      }
      
      // Normalize values from the form.
      const totalSupply = recordFormTotalSupplyInput.value;
      const quantity = recordFormQuantityInput.value;
      const price = `${Number(recordFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const beneficiary = recordFormBeneficiaryInput.value;
      const cpnBeneficiary = recordFormCpnBeneficiaryInput.value;
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));
      
      try {
        // Add a fee if the project being paid isn't the fee project ID.
        await tx_collect(projectId, category, totalSupply, price, quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value);

        // Hide the loading animation.
        stopLoadingAnimation('button-loading-animation');
      } catch (e) {
        // Hide the loading animation.
        stopLoadingAnimation('button-loading-animation');

        formErrorMessage.innerHTML = e;
        formErrorMessage.style.display = "block";
      }
    }
  };

  const decorateCollectForm = (chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice) => {
    // Get references to record form elements that need decorating.
    const collectFormHeader = document.getElementById("collect-form-header");
    const collectFormBeneficiaryInput = document.getElementById("collect-form-beneficiary-input");
    const collectFormCpnBeneficiaryInput = document.getElementById("collect-form-cpn-beneficiary-input");
    const collectFormQuantityInput = document.getElementById("collect-form-quantity-input");
    const collectFormPriceInput = document.getElementById("collect-form-price-input");
    const formErrorMessage = document.getElementById("form-error-message");
    const formSubmitButtonText = document.getElementById("form-submit-button-text");
    const formSubmitButton = document.getElementById("form-submit-button");
    const collectFormOptionsReveal = document.getElementById('collect-form-options-reveal');
    const collectFormDisclaimerReveal = document.getElementById('collect-form-disclaimer-reveal');

    // Toggle off the sections.
    collectFormOptionsReveal.open = false;
    collectFormDisclaimerReveal.open = false;

    // Set the header text.
    if (formattedRemainingSupply == 1) {
      collectFormHeader.innerHTML = `There is only 1 remaining edition of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice}.`;
    } else {
      collectFormHeader.innerHTML = `There are still ${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } remaining editions of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice} each.`;
    }

    // Change the button text.
    formSubmitButtonText.innerHTML = "collect";

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("collect-form-load-address-button");
    loadAddressButton.onclick = async () => {
      collectFormBeneficiaryInput.value = (await getSigner()).address;
    };

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set allowance values in the form if the fields are not yet set.
      if (!collectFormPriceInput.value) collectFormPriceInput.value = formattedPrice;

      // Set error messages if the currently inputted values are too small.
      if (collectFormPriceInput.value < formattedPrice) {
        formErrorMessage.innerHTML = `This NFT has a minimum price of <span class="ether">Ξ</span>${formattedPrice}.`;
        formErrorMessage.style.display = "block";
        formSubmitButton.disabled = true;
      } else if (collectFormQuantityInput.value > formattedRemainingSupply) {
        if (formattedRemainingSupply == 1) {
          formErrorMessage.innerHTML = `There is only 1 copy remaining. Can't mint ${collectFormQuantityInput.value}.`;
        } else {
          formErrorMessage.innerHTML = `There are only ${formattedRemainingSupply} copies remaining. Can't mint ${collectFormQuantityInput.value}.`;
        }
        formErrorMessage.style.display = "block";
        formSubmitButton.disabled = true;
      } else {
        // Hide the error message.
        formErrorMessage.style.display = "none";
        formSubmitButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price or quantity changes.
    collectFormPriceInput.addEventListener('input', queueCheckState);
    collectFormQuantityInput.addEventListener('input', queueCheckState);

    // Check the state.
    checkState();

    // Submit the form.
    formSubmitButton.onclick = async () => {
      // Make sure the form contents make sense.
      await checkState();
      if (formSubmitButton.disabled) return;

      // Show the loading animation.
      startLoadingAnimation('button-loading-animation');

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            // Hide the loading animation.
            stopLoadingAnimation('button-loading-animation');

            formErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            formErrorMessage.style.display = "block";
            return;
          }
      }

      // Normalize values from the form.
      const totalSupply = 1;
      const price = `${Number(collectFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const quantity = collectFormQuantityInput.value;
      const beneficiary = collectFormBeneficiaryInput.value;
      const cpnBeneficiary = collectFormCpnBeneficiaryInput.value;
      // Add a fee if the project being paid isn't the fee project ID.
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));
        
      try {
        await tx_collect(projectId, category, totalSupply, BigInt(price), quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value);

        // Hide the loading animation.
        stopLoadingAnimation('button-loading-animation');
      } catch (e) {
        // Hide the loading animation.
        stopLoadingAnimation('button-loading-animation');

        formErrorMessage.innerHTML = e;
        formErrorMessage.style.display = "block";
      }
    }
  };

  // Get the modal set up.
  const decorateModal = async (itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.
    const modal = document.getElementById("modal");
    const modalHeader = document.getElementById("modal-header");
    const modalSubtitle = document.getElementById("modal-subtitle");
    const modalContent = document.getElementById("modal-content");
    const formStateReveal = document.getElementById("form-state-reveal");
    const formErrorMessage= document.getElementById("form-error-message");
    const recordForm = document.getElementById("record-form");
    const collectForm = document.getElementById("collect-form");
    const modalLoadingAnimation = document.getElementById("modal-loading-animation");

    // Track the modal in browse history.
    history.pushState({ modalOpened: true, itemId: itemId }, "", "?id=" + itemId);

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    modal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    modal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT") return;

      // If there's a video, pause it.
      if (videoSrc) modalVideo.pause();

      // Hide the RECORD form.
      recordForm.style.display = "none";
      // Hide the COLLECT form.
      collectForm.style.display = "none";
      // Hide the error message.
      formErrorMessage.style.display = "none";
      // Close the state reveal.
      formStateReveal.open = false;

      // Hide the modal.
      modal.style.display = "none";

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
      
      // Reset the cache.
      allowanceCache = {};
      tiersCache = {};
    });

    // Decorate the frame's title.
    const frameName = document.getElementById("frame-name");
    const frameDate = document.getElementById("frame-date");
    frameName.innerHTML = name;
    frameDate.innerHTML = `${date} | `;

    // Show and populate the frame's subtitle if there's a link.
    if (link) {
      const frameLink = document.getElementById("frame-link");
      modalSubtitle.style.display = "block";
      frameLink.innerHTML = `<a href="${link}" target="_blank">${link}</a>`;
    } else {
      modalSubtitle.style.display = "none";
    }

    // Decordate the image or video content.
    const modalImage = document.getElementById("modal-image");
    const modalVideo = document.getElementById("modal-video");
    if (videoSrc) {
      modalImage.style.display = "none"
      modalVideo.style.display = "block"
      modalVideo.autoplay = true;
      modalVideo.loop = true;
      modalVideo.muted = true;
      modalVideo.controls = true;
      modalImage.src = "";
      modalVideo.src = videoSrc;
      modalVideo.addEventListener('click', (e) => e.stopPropagation());
    } else {
      modalImage.style.display = "block"
      modalVideo.style.display = "none"
      modalVideo.src = "";
      modalImage.src = imageSrc;
      modalImage.addEventListener('click', (e) => e.stopPropagation());
    }

    // Show the loading animation.
    startLoadingAnimation('modal-loading-animation');

    // Show the form.
    await decorateAndShowForm(itemId, encodedIPFSUri);

    // Hide the loading animation.
    stopLoadingAnimation('modal-loading-animation');
  }
    
  const encodeIPFSUriFrom = async (itemId) => {
    // Create the content's encoded IPFS URL.
    const cidUrl = `{{ assets_prefix }}${itemId}/nft.json.cid.txt`;
    const cid = await (await fetch(cidUrl)).text();
    return cid ? encodeIPFSUri(cid) : "";
  }

  const decorateFrame = async (frame, itemId, imageSrc, date, name, link, videoSrc) => {
    const encodedIPFSUri = await encodeIPFSUriFrom(itemId);

    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "✃";

    // Get references to frame elements that need decorating.
    const ctaAnchor = frame.querySelector('a');;
    const title = frame.querySelector('div.image-title');
    const img = frame.querySelector('img');

    // Set the frame and img's ID.
    frame.id = 'frame-' + itemId;
    img.id = 'img-' + itemId;

    // Set the content.
    ctaAnchor.textContent = '[record]';
    title.innerHTML = `<span><span class="image-date">${date} | </span>${ name }<span>`;

    // Mark videos with an icon.
    if (videoSrc) {
      const overlay = document.createElement("div");
      overlay.classList.add("overlay-icon");
      overlay.classList.add("video-icon");
      frame.appendChild(overlay);
    }

    // Summon a modal when the frame is clicked.
    frame.addEventListener("click", async (e) => {
      e.preventDefault();

      // Show the modal.
      modal.style.display = "block";

      // Make the modal look right.
      await decorateModal(itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc);
    });
  }

  /// Load the frame contents.
  const loadFrame = async (frame) => {
    const img = frame.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }

      checkForDimensions();
    });
  };

  /// Get the top.
  const getTopTarget = (frame, row) => {
      if (row == 1) {
        const frames = document.getElementById("frames");
        return frames.offsetTop;
      } 

    let previousRow = rows[row - 2];
    let candidateFrame;

    for (let j = 0; j < previousRow.frames.length; j++) {
      let frameToCheck = previousRow.frames[j];

      if (
        frame.left < frameToCheck.right + horizontalMargin &&
        frame.right + horizontalMargin > frameToCheck.left &&
        (candidateFrame == null || frameToCheck.bottom > candidateFrame.bottom)
      ) candidateFrame = frameToCheck;
      else if (frame.right <= frameToCheck.left) {
        return candidateFrame ? candidateFrame.bottom : getTopTarget(frame, row - 1);
      }
    }
    
    if (!candidateFrame) {
      console.log({ frame, row, previousRow });
    }
    return candidateFrame.bottom;
  }

  const frameImage = (src) => {
    const frames = document.getElementById("frames");
    const frame = document.createElement("div");
    const header = document.createElement("div");
    const title = document.createElement("div");
    const img = document.createElement("img");
    const cta = document.createElement("div");
    const ctaAnchor = document.createElement('a');

    frame.classList.add("frame");
    frame.style.transitionProperty = "opacity, margin-top";
    frame.style.transitionDuration = `${transitionDuration / 1000}s, ${transitionDuration / 1000}s`;
    frame.style.transitionTimingFunction = "ease, ease";
    header.classList.add("image-header");
    cta.classList.add("image-cta");
    title.classList.add("image-title");
    img.loading = "lazy";
    img.style.cursor = "pointer";

    // Get random width.
    const widthClass = widthClasses[Math.floor(Math.random() * widthClasses.length)];
    header.classList.add(widthClass);
    img.classList.add(widthClass);

    img.src = src;

    cta.appendChild(ctaAnchor);
    header.appendChild(cta);
    header.appendChild(title);
    frame.appendChild(header);
    frame.appendChild(img);
    frames.appendChild(frame);

    return frame;
  };

  const positionAndShowFrame = async (imageFrame) => {
    await loadFrame(imageFrame);

    if (loadingAnimationIntervals['main-loading-animation']) stopLoadingAnimation('main-loading-animation');

    const rect = imageFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;
    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
      let newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ frames: [newFrame] });
    else rows[rows.length - 1].frames.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = heightDiff + scrollTop - verticalMargin;
    imageFrame.classList.add("frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            imageFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        imageFrame.addEventListener("transitionend", handleEvent);
        imageFrame.style.marginTop = -marginTop + "px";
      } else setTimeout(resolve, transitionDuration);
    });
  }

  const loadImageFrames = async () => {
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const itemIds = [];
    const frames = data['articles']
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(item => item.hasVideo === true || item.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)))
      .map((item) => {
        items.push(item);
        // if item.hasVideo, use _videoThumbnail.png
        // else use a random attachment
        const imageName = item.hasVideo ? '_videoThumbnail.png' : item.attachments[Math.floor(Math.random() * item.attachments.length)];
        const videoName = item.hasVideo ? './' + item.id + '/' + item.videoFilename : null;
        const src = './' + item.id + '/' + imageName;
        const frame = frameImage(src);
        itemIds.push(item.id);
        decorateFrame(frame, item.id, src, formatTimestamp(item.created), item.title, item.externalLink, videoName);
        return frame;
      }
    );

    // if there is ?id= in the url, open the modal
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    if (id) {
      item = items.find(item => item.id == id);
      if (item) {
        const img = document.getElementById('img-' + item.id);
        if (img) setTimeout(() => img.click(), 200);
      }
    }

    encodedIPFSUris = await Promise.all(itemIds.map(async (itemId) => await encodeIPFSUriFrom(itemId)));

    const positionAndShowFrames = async () => {
      for (const frame of frames)
        await positionAndShowFrame(frame);
    };

    const loadFrameState = async () => { 
      // Load tiers.
      const formStateProjectId = document.getElementById("form-state-project-id");
      const projectId = parseInt(formStateProjectId.innerHTML);
      const tiers = await tx_view_tiers(projectId, encodedIPFSUris);

      for (let i in tiers) {
        const tier = tiers[i];
        if (tier.id != 0) {
          // Get a reference to the tier's remaining supply.
          const formattedRemainingSupply = parseInt(tier[2].toString());
          const frame = frames[i]; 
          const ctaAnchor = frame.querySelector('a');

          // Set the content.
          if (formattedRemainingSupply == 0) {
            ctaAnchor.textContent = '[sold out]';
            ctaAnchor.classList.add("sold-out");
          } else {
            ctaAnchor.textContent = `[${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left]`;
          }
        } 
      }
    }

    await Promise.all([loadFrameState(), positionAndShowFrames()]);
  };

  fetchSettings();
  loadImageFrames();
  startLoadingAnimation('main-loading-animation');
</script>
{% endblock %}
