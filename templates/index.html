{% extends 'base.html' %}
{% block head %}
{% include 'mmdules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const postModal = document.getElementById("post-modal");
    postModal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div class="top">
  {% if has_avatar == true %}
  <img src="{{ assets_prefix }}avatar.png" width="72" height="72" class="avatar">
  {% endif %}
  <div class="site-info">
    <div class="site-title">{{ page_title|escape }}</div>
    {% if page_description_html.count > 0 %}<div class="site-about">{{ page_description_html }}</div>{% endif %}
  </div>
  <div id="fork">fork</div>
  {% include 'modules/social_icons.html' %}
</div>
{% include 'modules/nav.html' %}
<div id="main-loading-animation" class="loading-animation"></div>
<div id="frames"></div>
<div id="fork-modal" class="modal closes-modal">
  <div class="modal-content closes-modal">
    <div class="modal-header closes-modal">
        Follow the instructions at <a href="https://croptop.eth.limo" target="_blank">https://croptop.eth</a> to set up your site and learn how to start posting.
      <div class="fork-info">
        You'll never be asked to sign up for an account or sign a blockchain transaction. All Croptop content exists peer-to-peer and is broadcasted using the Croptop app you'll download, there's no middleman corporation involved.
      </div>
      <div class="fork-info">
        If you want to let people pay you to record content onchain, you'll first need to create your Juicebox — an open source, community owned, and onchain programmable vending machine. You'll then add your Juicebox project ID into the settings of the Croptop app.
      </div>
      <div class="fork-info">
        You can create a simple Croptop-compatible Juicebox below. You can adjust it later on <a href="https://juicebox.money" target="_blank">https://juicebox.money</a>. It's recommended to send these transactions from the same forms over at <a href="https://croptop.eth.limo" target="_blank">https://croptop.eth</a> to make sure they haven't been tampered with.
      </div>
    </div>
    <div id="fork-form" class="form closes-modal">
      <div class="form-body">
        <details>
          <summary class="toggle main-toggle"><div>Make a new Juicebox</div></summary>
          <div class="form-section">
            <div class="form-section-description">Once deployed, you can find your Juicebox's project ID by looking for new projects at <a href="https://juicebox.money/projects?tab=new" target="_blank">https://juicebox.money/projects?tab=new</a>. The owner you set can edit this project at any time to change its description or set money rules.</div>
            <div class="form-item">
              <div class="form-label">Name</div>
              <div class="form-value">
                <input type="text" placeholder="Your collection name" id="fork-form-project-name-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item form-item-large">
              <div class="form-label">Owner 
                <button id="fork-form-load-address-button" class="load-address-button">[<span id="fork-form-load-address-button-text" class="load-address-button-text">connect wallet</span>]</button>
              </div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="fork-form-project-owner-input">
              </div>
            </div>
          </div>
          <div id="fork-form-new-jb-error-message" class="error-message"></div>
          <button id="fork-form-new-jb-submit-button" class="form-button">[<span id="fork-form-new-jb-submit-button-text" class="form-button-text">deploy project</span>]<span id="fork-form-new-jb-button-loading-animation" class="loading-animation"></span></button> 
        </details>
        <details>
          <summary class="toggle main-toggle"><div>Give the Croptop contract posting permissions to your project on your behalf</div></summary>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value">
                <input type="number" placeholder="420" id="fork-form-operator-project-id-input">
              </div>
            </div>
          </div>
          <div id="fork-form-permission-error-message" class="form-error-message"></div>
          <button id="fork-form-permission-submit-button" class="form-button">[<span id="fork-form-permission-submit-button-text" class="form-button-text">give permission</span>]<span id="fork-form-permission-button-loading-animation" class="loading-animation"></span></button> 
        </details>
        <details>
          <summary class="toggle main-toggle"><div>Set the conditions that Croptop posts must meet when made to your Juicebox</div></summary>
          <div class="form-section">
            <div class="form-section-description">A post's minting parameters are chosen by the collector at the time they record it onchain. Anyone can post any content from anywhere to your Juicebox, so long as these allowances that you set are met.</div>
            <div class="form-item">
              <div class="form-label">Minimum price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" value="0.01" id="fork-form-minimum-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Min total supply</div>
              <div class="form-value">
                <input type="number" value="1" id="fork-form-minimum-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Max total supply</div>
              <div class="form-value">
                <input type="number" value="1000000000" id="fork-form-maximum-total-supply-input">
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item form-item-large">
              <div class="form-label">Allowed addresses (comma separated)</div>
              <div class="form-value">
                <textarea rows="4" id="fork-form-allowed-addresses-input" placeholder="0x19ca78b53934f7c3b5d719a377883e03614003de, 0x19ca78b53934f7c3b5d719a377883e03614003de"></textarea>
              </div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">NFT category on your Juicebox for which the above allowances apply</div>
              <div class="form-value">
                <input type="number" value="0" id="fork-form-nft-category-input">
              </div>
            </div>
          </div>
          <div id="fork-form-allowance-error-message" class="form-error-message"></div>
          <button id="fork-form-allowance-submit-button" class="form-button">[<span id="fork-form-allowance-submit-button-text" class="form-button-text">save allowances</span>]<span id="fork-form-allowance-button-loading-animation" class="loading-animation"></span></button> 
        </details>
      </div>
    </div>
  </div>
</div>
<div id="post-modal" class="modal closes-modal">
  <div class="modal-content closes-modal">
    <div class="modal-header closes-modal">
      <span id="frame-date"></span><span id="frame-name"></span>
      <div id="frame-subtitle" class="closes-modal">
          <span id="frame-link"></span>
      </div>
      <div id="form-state" class="closes-modal">
        <details id="form-state-reveal">
          <summary id="form-state-toggle" class="toggle"><span id="form-state-chain" class="form-state-item-value"></span>, project ID: <a id="form-state-project-id" class="form-state-item-value" target="_blank"></a>, NFT category ID: <span id="form-state-nft-category" class="form-state-item-value"></span></summary>
          <div class="form-section-description">Specify the Juicebox project that is being funded from this NFT sale and the category under which it will appear. Changing these values will change the availability of this NFT.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Chain</div>
              <div class="form-value form-select-value">
                <select id="form-state-chain-input" name="chain">
                  <option value="mainnet">mainnet</option>
                  <option value="goerli">goerli</option>
                  <option value="polygon">polygon</option>
                </select>
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Project ID</div>
              <div class="form-value"><input type="number" value="" id="form-state-project-id-input"></div>
            </div>
            <div class="form-item">
              <div class="form-label">NFT category ID</div>
              <div class="form-value"><input type="number" value="" id="form-state-nft-category-input"></div>
            </div>
          </div>
          <div id="form-state-error-message" class="form-error-message"></div>
          <button id="form-state-button" class="form-button">[<span id="form-state-button-text" class="form-button-text">update</span>]</button>
        </details>
      </div>
    </div>
    <div id="collect-post-form" class="form closes-modal">
      <span id="collect-post-form-header" class="form-header"></span>
      <div class="form-body">
        <details id="collect-post-form-options-reveal">
          <summary id="collect-post-form-options-toggle" class="toggle main-toggle"><div>options</div></summary>
          <div class="form-section-description">Determine the price you want to pay and the address that will be sent the copy you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="number" value="" id="collect-post-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="collect-post-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address <button id="collect-post-form-load-address-button" class="load-address-button">[<span id="collect-post-form-load-address-button-text" class="load-address-button-text">connect wallet</span>]</button></div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="collect-post-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
          <details id="collect-post-form-disclaimer-reveal">
            <summary id="collect-post-form-disclaimer-toggle" class="toggle disclaimer-toggle"><div>override $CPN beneficiary</div></summary>
            <div class="form-section">
              <div class="form-item form-item-large">
                <div class="form-label">$CPN Beneficiary Address</div>
                <div class="form-value">
                  <input type="text" placeholder="Defaults to the address of this site's author" id="collect-post-form-cpn-beneficiary-input">
                </div>
              </div>
            </div>
          </details>
        </details>
      </div>
    </div>
    <div id="record-post-form" class="form closes-modal">
      <span class="form-header">This file isn't yet onchain. Record it onchain to collect a first copy.</span>
      <div class="form-body">
        <details id="record-post-form-options-reveal">
          <summary id="record-post-form-options-toggle" class="toggle main-toggle"><div>options</div></summary>
          <div class="form-section-description">Set the NFT's price, how many editions of this NFT will be made available for collecting, and the address that will be sent its first copies that you are paying for.</div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Price</div>
              <div class="form-value">
                <span class="ether">Ξ</span><input type="text" value="" id="record-post-form-price-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Total supply</div>
              <div class="form-value">
                <input type="number" placeholder="10" value="" id="record-post-form-total-supply-input">
              </div>
            </div>
            <div class="form-item">
              <div class="form-label">Quantity to mint</div>
              <div class="form-value">
                <input type="number" value="1" id="record-post-form-quantity-input">
              </div>
            </div>
            <div class="form-item form-item-large">
              <div class="form-label">Address 
                <button id="record-post-form-load-address-button" class="load-address-button">[<span id="record-post-form-load-address-button-text" class="load-addres-button-text">connect wallet</span>]</button>
              </div>
              <div class="form-value">
                <input type="text" placeholder="Defaults to your address" id="record-post-form-beneficiary-input">
              </div>
            </div>
          </div>
          <div class="form-section-disclaimer">An added 5% is sent to the <a href="https://goerli.juicebox.money/v2/p/669" target="_blank">Croptop Publishing Network</a> in exchange for $CPN to this site's author.</div>
          <details id="record-post-form-disclaimer-reveal">
            <summary id="record-post-form-disclaimer-toggle" class="toggle disclaimer-toggle"><div>override $CPN beneficiary</div></summary>
            <div class="form-section">
              <div class="form-item form-item-large">
                <div class="form-label">$CPN Beneficiary Address</div>
                <div class="form-value">
                  <input type="text" placeholder="Defaults to the address of this site's author" id="record-post-form-cpn-beneficiary-input">
                </div>
              </div>
            </div>
          </details>
        </details>
      </div>
    </div>
    <div id="post-form-modal-loading-animation" class="loading-animation"></div>
    <div id="post-form-error-message" class="form-error-message"></div>
    <button id="post-form-button" class="form-button">[<span id="post-form-button-text" class="form-button-text">collect</span>]<span id="post-form-button-loading-animation" class="loading-animation"></span></button> 
    <img id="modal-image"></img>
    <video id="modal-video"></video>
  </div>
</div>
<script>
  // Layout constants.
  const horizontalMargin = 24;
  const verticalMargin = 10;
  const transitionDuration = 300;
  const widthClasses = ["w1", "w2", "w3"];
  const loadingAnimationPace = 100;
  const formInputReactionTimeDelay = 600;

  // State constants.
  const feeDivisor = 20;

  // Layout variables.
  let frames;
  let items = Array();
  let loadingAnimationIntervals = {};
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];

  // State variables.
  let signer;
  let encodedIPFSUris;
  let allowanceCache = {};
  let tiersCache = {};
  let defaultChain = "goerli";  
  let defaultNftCategory = 0;
  let defaultEthAddress;
  let formState;
    
  const resolveChainId = (value) => {
    switch (value) {
      case "mainnet": return 1; 
      case "goerli": return 5; 
    }
  }

  const resolveChainSelectIndex = (chain) => {
    switch (chain) {
      case "mainnet": return 0; 
      case "goerli": return 1; 
      case "polygon": return 2; 
    }
  }

  const resolveChain = (chainId) => {
    switch (chainId) {
      case 1: return "mainnet"; 
      case 5: return "goerli"; 
    }
  }

  const cpnProjectId = (chain) => {
    switch (chain) {
      case "mainnet":
        return 500;
      case "goerli":
        return 758;
      case "polygon":
        return 78;
    }
  }

  const projectLinkBase = (chain) => {
    switch (chain) {
      case "mainnet": 
        return "https://juicebox.money/v2/p/";
      case "goerli": 
        return "https://goerli.juicebox.money/v2/p/";
      case "polygon": 
        return "https://beta.polygon.juicebox.money/v2/p/";
    }
  }

  const loadFrameState = async () => { 
    // Load tiers.
    const formStateChain = document.getElementById("form-state-chain");
    const formStateProjectId = document.getElementById("form-state-project-id");
    const chain = formStateChain.innerHTML;
    const projectId = parseInt(formStateProjectId.innerHTML);

    const tiers = await tx_view_tiers(projectId, encodedIPFSUris, resolveChainId(chain));
    
    console.log({  tiers });

    for (let i in tiers) {
      const tier = tiers[i];
      if (tier.id != 0) {

        // Cache the value.
        if (!tiersCache[projectId]) tiersCache[projectId] = {};
        tiersCache[projectId][encodedIPFSUris[i]] = tier;

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());
        const frame = frames[i]; 
        const ctaAnchor = frame.querySelector('a');

        // Set the content.
        if (formattedRemainingSupply == 0) {
          ctaAnchor.textContent = '[sold out]';
          ctaAnchor.classList.add("sold-out");
        } else {
          ctaAnchor.textContent = `[${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left]`;
        }
      } 
    }
  }

  /// Get admin settings.
  const fetchSettings = () => {
    const formStateChain = document.getElementById("form-state-chain");
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");

    formStateChain.innerHTML = defaultChain;
    formStateProjectId.innerHTML = cpnProjectId(defaultChain);
    formStateNftCategory.innerHTML = defaultNftCategory;

    fetch("{{ assets_prefix }}templateSettings.json")
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        if (data.chain != null) formStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        if (data.juiceboxProjectID != null) formStateProjectId.innerHTML = Number(data.juiceboxProjectID);
        // data.juiceboxProjectIDGoerli is also available if you need it
        if (data.nftCategory != null) formStateNftCategory.innerHTML = Number(data.nftCategory);
        if (data.ethAddress) defaultEthAddress = data.ethAddress;
      });
  }

  /// Animate the loading ticker.
  const startLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimation.style.display = "inherit";
    const loadingAnimationFrames = ['-', '\\', '|', '/'];
    let currentFrame = 0;

    const animate = () => {
      loadingAnimation.textContent = loadingAnimationFrames[currentFrame];
      currentFrame = (currentFrame + 1) % loadingAnimationFrames.length;
      loadingAnimationIntervals[loadingAnimationId] = setTimeout(animate, loadingAnimationPace);
    }

    animate();
  }

  /// Stop animating the loading ticker.
  const stopLoadingAnimation = (loadingAnimationId) => {
    const loadingAnimation = document.getElementById(loadingAnimationId);
    loadingAnimationIntervals[loadingAnimationId] = clearTimeout(loadingAnimationIntervals[loadingAnimationId]);
    loadingAnimation.style.display = "none";
  }

  // Re-decorate the form depending on if the provided content has already been recorded onchain, and if it's sold out.
  const decorateAndShowForm = async (itemId, encodedIPFSUri) => {
    console.log("decorating");
    // Get references to the form state.
    const formStateChain = document.getElementById("form-state-chain");
    const formStateProjectId = document.getElementById("form-state-project-id");
    const formStateNftCategory = document.getElementById("form-state-nft-category");
    const formStateChainInput = document.getElementById("form-state-chain-input");
    const formStateProjectIdInput = document.getElementById("form-state-project-id-input");
    const formStateNftCategoryInput = document.getElementById("form-state-nft-category-input");
    const formStateReveal = document.getElementById("form-state-reveal");
    const formStateErrorMessage = document.getElementById("form-state-error-message");
    const formStateButton = document.getElementById("form-state-button");
    const postFormErrorMessage = document.getElementById("post-form-error-message");
    const postFormButton = document.getElementById("post-form-button");

    // Get references to the two possible forms.
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");

    const updateFormState = async () => {
      // Get a reference to the chain, project ID, and category fields.
      const chain = formStateChain.innerHTML;
      const projectId = parseInt(formStateProjectId.innerHTML);
      const category = parseInt(formStateNftCategory.innerHTML);

      // Set the project ID href.
      formStateProjectId.setAttribute('href', `${projectLinkBase(chain)}${formStateProjectId.innerHTML}`);

      // Look in the cache for tiers within the project ID.
      const projectIdTiers = tiersCache[projectId];

      // If there's no cache for the project ID, set it to an empty object.
      if (!projectIdTiers) tiersCache[projectId] = {};

      // Look in the cache for a tier for the project ID and encodedIPFSUri.
      let tier = tiersCache[projectId][encodedIPFSUri];
        
      console.log({  cahcedTier: tier });

      // If nothing is cached, load from the contract.
      if (!tier) {

        // Check to see if there's a tier for this content.
        [tier] = await tx_view_tiers(projectId, [encodedIPFSUri], resolveChainId(chain));

        console.log({  tier });
        // Cache the value.
        tiersCache[projectId][encodedIPFSUri] = tier;
      }

      // Get a reference to the tier's ID.
      const formattedTierId = parseInt(tier[0].toString());

      // If there is no tier, the form's state is in RECORD mode, meaning the content must be recorded onchain before it can be collected.
      if (formattedTierId != 0) {
        // The form's state is in COLLECT mode, meaning new editions can be minted from an already-recorded NFT tier.

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());

        // If there's no remaining supply, the form's state is in SOLD_OUT mode, meaning it can't be minted anymore.
        if (formattedRemainingSupply == 0) {
          // Show the error message.
          postFormErrorMessage.innerHTML = "This NFT is sold out";
          postFormErrorMessage.style.display = "block";
          // Hide the forms.
          recordPostForm.style.display = "none";
          collectPostForm.style.display = "none";
          // Disable the button.
          postFormButton.disabled = true;
          return;
        }

        // Show the COLLECT form.
        collectPostForm.style.display = "block";
        // Hide the RECORD form.
        recordPostForm.style.display = "none";
        // Hide the error message.
        postFormErrorMessage.style.display = "none";

        // Get a reference to the tier's price.
        const formattedPrice = ethers.formatEther(tier[1]);

        // Show the form.
        await decorateCollectForm(chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice);
      } else {
        // Check to see if the project and category allow posting.

        // Look in the cache for allowances within the project ID.
        const projectIdAllowances = allowanceCache[projectId];

        // If there's no cache for the project ID, set it to an empty object.
        if (!projectIdAllowances) allowanceCache[projectId] = {};

        // Look in the cache for an allowance for the category within the allowances for the project ID.
        let allowance = allowanceCache[projectId][category];

        console.log({  chached: allowance })
        // If nothing is cached, load from the contract.
        if (!allowance) {
          // Get the allowance.
          allowance = await tx_view_allowance(projectId, category, resolveChainId(chain));
          console.log({  allowance });

          // Cache the value.
          allowanceCache[projectId][category] = allowance;
        }

        // Get a reference to the allowance min total supply.
        const formattedMinTotalSupply = parseInt(allowance[1].toString());

        // Show an error message if there's no allowance set.
        if (formattedMinTotalSupply == 0) {
          // Show the error message.
          postFormErrorMessage.innerHTML = `Project ${projectId} isn't accepting posts on category ${category} yet.`;
          postFormErrorMessage.style.display = "block";
          // Hide forms.
          recordPostForm.style.display = "none";
          collectPostForm.style.display = "none";
          // Disable the button.
          postFormButton.disabled = true;
          return;
        }

        // Show the RECORD form.
        recordPostForm.style.display = "block";
        // Hide the COLLECT form.
        collectPostForm.style.display = "none";
        // Hide the error message.
        postFormErrorMessage.style.display = "none";

        // Get a reference to the allowance min price.
        const formattedMinPrice = ethers.formatEther(allowance[0]);

        // Get a reference to the allowance max total supply.
        const formattedMaxTotalSupply = parseInt(allowance[2].toString());

        // Get a reference to the allowance max total supply.
        const formattedAllowedAddresses = allowance[3];

        await decorateRecordForm(chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses);
      }
    }
    
    // Populate the state input values when opened.
    formStateReveal.addEventListener("toggle", () => {
      if (!this.open) return;
      formStateChainInput.selectedIndex = resolveChainSelectIndex(formStateChain.innerHTML);
      formStateProjectIdInput.value = formStateProjectId.innerHTML;
      formStateNftCategoryInput.value = formStateNftCategory.innerHTML;
    });

    // Change the project ID input on network change to the default.
    formStateChainInput.addEventListener("change", () => {
      formStateProjectIdInput.value = cpnProjectId(formStateChainInput.value);
    });

    // Submit the state change form.
    formStateButton.onclick = async () => {
      // Check for empty values.
      if (formStateProjectIdInput.value == "" || formStateNftCategoryInput.value == "") {
        formStateErrorMessage.innerHTML = `Missing values.`;
        formStateErrorMessage.style.display = "block";
        return;
      } else {
        formStateErrorMessage.style.display = "none";
      }
      
      // Reload the mint state if the chain changed.
      if (formStateChain.innerHTML != formStateChainInput.value) {
        // Reload the state.
        await loadFrameState();

        formStateChain.innerHTML = formStateChainInput.value; 
      }

      formStateProjectId.innerHTML = formStateProjectIdInput.value;
      formStateProjectId.setAttribute('href', `${projectLinkBase(formStateChain.innerHTML)}${formStateProjectId.innerHTML}`);
      formStateNftCategory.innerHTML = formStateNftCategoryInput.value; 

      // Close the state change form.
      formStateReveal.open = false;

      // Show the loading animation.
      startLoadingAnimation('post-form-modal-loading-animation');

      // Update the form's state.
      await updateFormState();

      // Show the loading animation.
      stopLoadingAnimation('post-form-modal-loading-animation');
    }
    
    console.log("updating state");
    updateFormState();
  }

  const decorateRecordForm = async (chain, projectId, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses) => {
    // Get references to record form elements that need decorating.
    const recordPostFormBeneficiaryInput = document.getElementById("record-post-form-beneficiary-input");
    const recordPostFormCpnBeneficiaryInput = document.getElementById("record-post-form-cpn-beneficiary-input");
    const recordPostFormTotalSupplyInput = document.getElementById("record-post-form-total-supply-input");
    const recordPostFormPriceInput = document.getElementById("record-post-form-price-input");
    const recordPostFormQuantityInput = document.getElementById("record-post-form-quantity-input");
    const recordPostFormErrorMessage = document.getElementById("post-form-error-message");
    const recordPostFormButtonText = document.getElementById("post-form-button-text");
    const recordPostFormButton = document.getElementById("post-form-button");
    const recordPostFormOptionsReveal = document.getElementById('record-post-form-options-reveal');
    const recordPostFormDisclaimerReveal = document.getElementById('record-post-form-disclaimer-reveal');

    // Toggle off the sections.
    recordPostFormOptionsReveal.open = false;
    recordPostFormDisclaimerReveal.open = false;

    // Change the button text.
    postFormButtonText.innerHTML = "record & collect";

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error message if not allowed.
      if (signer && formattedAllowedAddresses.length && !formattedAllowedAddresses.includes(signer)) {
        postFormErrorMessage.innerHTML = `Project ${projectId} has reserved posting to category ${category} for these addresses: ${formattedAllowedAddresses}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      // Set error messages if the currently inputted values are too small.
      } else if (recordPostFormPriceInput.value < formattedMinPrice || recordPostFormTotalSupplyInput.value < formattedMinTotalSupply || recordPostFormTotalSupplyInput.value > formattedMaxTotalSupply) {
        postFormErrorMessage.innerHTML = `Project ${projectId} has a minimum price of <span class="ether">Ξ</span>${formattedMinPrice}, a minimum total supply of ${formattedMinTotalSupply}, and a maximum total supply of ${formattedMaxTotalSupply} to record on category ${category}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else if (recordPostFormQuantityInput.value > recordPostFormTotalSupplyInput.value) {
        postFormErrorMessage.innerHTML = `The total supply is ${recordPostFormTotalSupplyInput.value}. Can't mint ${recordPostFormQuantityInput.value}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else {
        // Hide the error message.
        postFormErrorMessage.style.display = "none";
        postFormButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer; 
      const queueCheckState = async () => { 
        clearTimeout(checkStateTimer); 
        checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price, total supply, or quantity changes.
    recordPostFormPriceInput.addEventListener("input", queueCheckState);
    recordPostFormTotalSupplyInput.addEventListener("input", queueCheckState);
    recordPostFormQuantityInput.addEventListener("input", queueCheckState);

    // Set values in the form if the fields are not yet set.
    if (!recordPostFormBeneficiaryInput.value && signer) recordPostFormBeneficiaryInput.value = signer;
    if (!recordPostFormPriceInput.value) recordPostFormPriceInput.value = formattedMinPrice;
    if (!recordPostFormTotalSupplyInput.value) recordPostFormTotalSupplyInput.value = formattedMinTotalSupply;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("record-post-form-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      recordPostFormBeneficiaryInput.value = signer;
      await checkState();
    };
    
    // Submit the form.
    postFormButton.onclick = async () => {
      // Check for empty values.
      if (recordPostFormPriceInput.value == "" || recordPostFormTotalSupplyInput.value == "" || recordPostFormQuantityInput.value == "") {
        postFormErrorMessage.innerHTML = `Missing values.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
        return;
      } 

      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');
        
      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the form contents make sense.
      await checkState();

      if (postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            postFormErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            postFormErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('post-form-button-loading-animation');

            return;
          }
      }
      
      // Normalize values from the form.
      const totalSupply = recordPostFormTotalSupplyInput.value;
      const quantity = recordPostFormQuantityInput.value;
      const price = `${Number(recordPostFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const beneficiary = recordPostFormBeneficiaryInput.value;
      const cpnBeneficiary = recordPostFormCpnBeneficiaryInput.value;
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(projectId, category, totalSupply, price, quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));
      
          // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          postFormErrorMessage.innerHTML = "The connected network isn't supported.";
          postFormErrorMessage.style.display = "block";

          // Disable the button.
          postFormButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        postFormErrorMessage.innerHTML = e;
        postFormErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  const decorateCollectForm = async (chain, projectId, category, encodedIPFSUri, formattedRemainingSupply, formattedPrice) => {
    // Get references to record form elements that need decorating.
    const collectPostFormHeader = document.getElementById("collect-post-form-header");
    const collectPostFormBeneficiaryInput = document.getElementById("collect-post-form-beneficiary-input");
    const collectPostFormCpnBeneficiaryInput = document.getElementById("collect-post-form-cpn-beneficiary-input");
    const collectPostFormQuantityInput = document.getElementById("collect-post-form-quantity-input");
    const collectPostFormPriceInput = document.getElementById("collect-post-form-price-input");
    const postFormErrorMessage = document.getElementById("post-form-error-message");
    const postFormButtonText = document.getElementById("post-form-button-text");
    const postFormButton = document.getElementById("post-form-button");
    const collectPostFormOptionsReveal = document.getElementById("collect-post-form-options-reveal");
    const collectPostFormDisclaimerReveal = document.getElementById("collect-post-form-disclaimer-reveal");

    // Toggle off the sections.
    collectPostFormOptionsReveal.open = false;
    collectPostFormDisclaimerReveal.open = false;

    // Set the header text.
    if (formattedRemainingSupply == 1) {
      collectPostFormHeader.innerHTML = `There is only 1 remaining edition of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice}.`;
    } else {
      collectPostFormHeader.innerHTML = `There are still ${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } remaining editions of this file available to be collected for <span class="ether">Ξ</span>${formattedPrice} each.`;
    }

    // Change the button text.
    postFormButtonText.innerHTML = "collect";

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error messages if the currently inputted values are too small.
      if (collectPostFormPriceInput.value < formattedPrice) {
        postFormErrorMessage.innerHTML = `This NFT has a minimum price of <span class="ether">Ξ</span>${formattedPrice}.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else if (collectPostFormQuantityInput.value > formattedRemainingSupply) {
        if (formattedRemainingSupply == 1) {
          postFormErrorMessage.innerHTML = `There is only 1 copy remaining. Can't mint ${collectPostFormQuantityInput.value}.`;
        } else {
          postFormErrorMessage.innerHTML = `There are only ${formattedRemainingSupply} copies remaining. Can't mint ${collectPostFormQuantityInput.value}.`;
        }
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
      } else {
        // Hide the error message.
        postFormErrorMessage.style.display = "none";
        postFormButton.disabled = false;
      }
    }

    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);
      checkStateTimer = setTimeout(checkState, formInputReactionTimeDelay);
    }

    // Update the form's state each time the price or quantity changes.
    collectPostFormPriceInput.addEventListener("input", queueCheckState);
    collectPostFormQuantityInput.addEventListener("input", queueCheckState);

    // Set values in the form if the fields are not yet set.
    if (!collectPostFormBeneficiaryInput.value && signer) collectPostFormBeneficiaryInput.value = signer;
    if (!collectPostFormPriceInput.value) collectPostFormPriceInput.value = formattedPrice;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("collect-post-form-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      collectPostFormBeneficiaryInput.value = signer;
      await checkState();
    };

    // Submit the form.
    postFormButton.onclick = async () => {
      // Check for empty values.
      if (collectPostFormPriceInput.value == "" || collectPostFormQuantityInput.value == "") {
        postFormErrorMessage.innerHTML = `Missing values.`;
        postFormErrorMessage.style.display = "block";
        postFormButton.disabled = true;
        return;
      } 

      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the form contents make sense.
      await checkState();

      if (postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');

        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
        try {
          await switchChain(expectedChainId); 
        } catch (e) {
          postFormErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
          postFormErrorMessage.style.display = "block";

          // Hide the loading animation.
          stopLoadingAnimation('post-form-button-loading-animation');

          return;
        }
      }

      // Normalize values from the form.
      const totalSupply = 1;
      const price = `${Number(collectPostFormPriceInput.value) * 1_000_000_000_000_000_000}`;
      const quantity = collectPostFormQuantityInput.value;
      const beneficiary = collectPostFormBeneficiaryInput.value;
      const cpnBeneficiary = collectPostFormCpnBeneficiaryInput.value;
      // Add a fee if the project being paid isn't the fee project ID.
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((projectId == await cpnProjectId(chain)) ? BigInt(0) : (totalPrice / BigInt(feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(projectId, category, totalSupply, BigInt(price), quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));
        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          postFormErrorMessage.innerHTML = "The connected network isn't supported.";
          postFormErrorMessage.style.display = "block";

          // Disable the button.
          postFormButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        postFormErrorMessage.innerHTML = e;
        postFormErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  // Get the modal set up.
  const decorateAndShowPostModal = async (itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.
    const postModal = document.getElementById("post-modal");
    const frameSubtitle = document.getElementById("frame-subtitle");
    const frameLink = document.getElementById("frame-link");
    const formStateReveal = document.getElementById("form-state-reveal");
    const postFormErrorMessage= document.getElementById("post-form-error-message");
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");

    // Show the modal.
    postModal.style.display = "block";

    // Track the modal in browse history.
    history.pushState({ modalOpened: true, itemId: itemId }, "", "?id=" + itemId);

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    postModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    postModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT") return;

      // If there's a video, pause it.
      if (videoSrc) modalVideo.pause();

      // Hide the RECORD form.
      recordPostForm.style.display = "none";
      // Hide the COLLECT form.
      collectPostForm.style.display = "none";
      // Hide the error message.
      postFormErrorMessage.style.display = "none";
      // Close the state reveal.
      formStateReveal.open = false;

      // Hide the modal.
      postModal.style.display = "none";

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
    });

    // Decorate the frame's title.
    const frameName = document.getElementById("frame-name");
    const frameDate = document.getElementById("frame-date");
    frameName.innerHTML = name;
    frameDate.innerHTML = `${date} | `;

    // Show and populate the frame's subtitle if there's a link.
    if (link) {
      frameSubtitle.style.display = "block";
      frameLink.innerHTML = `<a href="${link}" target="_blank">${link}</a>`;
    } else {
      frameSubtitle.style.display = "none";
    }

    // Decordate the image or video content.
    const modalImage = document.getElementById("modal-image");
    const modalVideo = document.getElementById("modal-video");
    if (videoSrc) {
      modalImage.style.display = "none"
      modalVideo.style.display = "block"
      modalVideo.autoplay = true;
      modalVideo.loop = true;
      modalVideo.muted = true;
      modalVideo.controls = true;
      modalImage.src = "";
      modalVideo.src = videoSrc;
      modalVideo.addEventListener("click", (e) => e.stopPropagation());
    } else {
      modalImage.style.display = "block"
      modalVideo.style.display = "none"
      modalVideo.src = "";
      modalImage.src = imageSrc;
      modalImage.addEventListener("click", (e) => e.stopPropagation());
    }

    // Show the loading animation.
    startLoadingAnimation('post-form-modal-loading-animation');

    // Show the form.
    await decorateAndShowForm(itemId, encodedIPFSUri);

    // Hide the loading animation.
    stopLoadingAnimation('post-form-modal-loading-animation');
  }
    
  const encodeIPFSUriFrom = async (itemId) => {
    // Create the content's encoded IPFS URL.
    const cidUrl = `{{ assets_prefix }}${itemId}/nft.json.cid.txt`;
    const cid = await (await fetch(cidUrl)).text();
    return cid ? encodeIPFSUri(cid) : "";
  }

  const decorateFrame = async (frame, itemId, imageSrc, date, name, link, videoSrc) => {
    const encodedIPFSUri = await encodeIPFSUriFrom(itemId);

    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "✃";

    // Get references to frame elements that need decorating.
    const ctaAnchor = frame.querySelector('a');;
    const title = frame.querySelector('div.image-title');
    const img = frame.querySelector('img');

    // Set the frame and img's ID.
    frame.id = 'frame-' + itemId;
    img.id = 'img-' + itemId;

    // Set the content.
    ctaAnchor.textContent = '[record]';
    title.innerHTML = `<span><span class="image-date">${date} | </span>${ name }<span>`;

    // Mark videos with an icon.
    if (videoSrc) {
      const overlay = document.createElement("div");
      overlay.classList.add("overlay-icon");
      overlay.classList.add("video-icon");
      frame.appendChild(overlay);
    }

    // Summon a modal when the frame is clicked.
    frame.addEventListener("click", async (e) => {
      e.preventDefault();

      // Make the modal look right.
      await decorateAndShowPostModal(itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc);
    });
  }

  /// Load the frame contents.
  const loadFrame = async (frame) => {
    const img = frame.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }

      checkForDimensions();
    });
  }

  /// Get the top.
  const getTopTarget = (frame, row) => {
    if (row == 1) {
      const frames = document.getElementById("frames");
      return frames.offsetTop;
    } 

    let previousRow = rows[row - 2];
    let candidateFrame;

    for (let j = 0; j < previousRow.frames.length; j++) {
      let frameToCheck = previousRow.frames[j];

      if (
        frame.left < frameToCheck.right + horizontalMargin &&
        frame.right + horizontalMargin > frameToCheck.left &&
        (candidateFrame == null || frameToCheck.bottom > candidateFrame.bottom)
      ) candidateFrame = frameToCheck;
      else if (frame.right <= frameToCheck.left) {
        return candidateFrame ? candidateFrame.bottom : getTopTarget(frame, row - 1);
      }
    }
    
    if (!candidateFrame) {
      console.log({ frame, row, previousRow });
    }
    return candidateFrame.bottom;
  }

  const frameImage = (src) => {
    const frames = document.getElementById("frames");
    const frame = document.createElement("div");
    const header = document.createElement("div");
    const title = document.createElement("div");
    const img = document.createElement("img");
    const cta = document.createElement("div");
    const ctaAnchor = document.createElement('a');

    frame.classList.add("frame");
    frame.style.transitionProperty = "opacity, margin-top";
    frame.style.transitionDuration = `${transitionDuration / 1000}s, ${transitionDuration / 1000}s`;
    frame.style.transitionTimingFunction = "ease, ease";
    header.classList.add("image-header");
    cta.classList.add("image-cta");
    title.classList.add("image-title");
    img.loading = "lazy";
    img.style.cursor = "pointer";

    // Get random width.
    const widthClass = widthClasses[Math.floor(Math.random() * widthClasses.length)];
    header.classList.add(widthClass);
    img.classList.add(widthClass);

    img.src = src;

    cta.appendChild(ctaAnchor);
    header.appendChild(cta);
    header.appendChild(title);
    frame.appendChild(header);
    frame.appendChild(img);
    frames.appendChild(frame);

    return frame;
  }

  const positionAndShowFrame = async (imageFrame) => {
    await loadFrame(imageFrame);

    if (loadingAnimationIntervals['main-loading-animation']) stopLoadingAnimation('main-loading-animation');

    const rect = imageFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;
    
    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
      let newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ frames: [newFrame] });
    else rows[rows.length - 1].frames.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = heightDiff + scrollTop - verticalMargin;
    imageFrame.classList.add("frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            imageFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        imageFrame.addEventListener("transitionend", handleEvent);
        imageFrame.style.marginTop = -marginTop + "px";
      } else setTimeout(resolve, transitionDuration);
    });
  }

  const loadImageFrames = async () => {
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const itemIds = [];
    frames = data['articles']
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(item => item.hasVideo === true || item.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)))
      .map((item) => {
        items.push(item);
        // if item.hasVideo, use _videoThumbnail.png
        // else use a random attachment
        const imageName = item.hasVideo ? '_videoThumbnail.png' : item.attachments[Math.floor(Math.random() * item.attachments.length)];
        const videoName = item.hasVideo ? './' + item.id + '/' + item.videoFilename : null;
        const src = './' + item.id + '/' + imageName;
        const frame = frameImage(src);
        itemIds.push(item.id);
        decorateFrame(frame, item.id, src, formatTimestamp(item.created), item.title, item.externalLink, videoName);
        return frame;
      }
    );

    // if there is ?id= in the url, open the modal
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    if (id) {
      item = items.find(item => item.id == id);
      if (item) {
        const img = document.getElementById('img-' + item.id);
        if (img) setTimeout(() => img.click(), 200);
      }
    }

    encodedIPFSUris = await Promise.all(itemIds.map(async (itemId) => await encodeIPFSUriFrom(itemId)));

    const positionAndShowFrames = async () => {
      for (const frame of frames)
        await positionAndShowFrame(frame);
    };

    await Promise.all([loadFrameState(), positionAndShowFrames()]);
  }

  const decorateNewJbForm = () => {
    const forFormProjectNameInput = document.getElementById("fork-form-project-name-input");
    const forkFormProjectOwnerInput = document.getElementById("fork-form-project-owner-input");
    const forkFormNewJbErrorMessage = document.getElementById("fork-form-new-jb-error-message");
    const forkFormNewJbSubmitButton = document.getElementById("fork-form-new-jb-submit-button");

    // Set values in the form if the fields are not yet set.
    if (!collectPostFormBeneficiaryInput.value && signer) collectPostFormBeneficiaryInput.value = signer;

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("fork-form-load-address-button");
    loadAddressButton.onclick = async () => {
      signer = (await getSigner()).address;
      forkFormBeneficiaryInput.value = signer;
      await checkState();
    };

    // Submit the form.
    forkFormNewJbSubmitButton.onclick = async () => {
      // Check for empty values.
      if (forFormProjectNameInput.value == "" || forkFormProjectOwnerInput.value == "") {
        forkFormNewJbErrorMessage.innerHTML = `Missing values.`;
        forkFormNewJbErrorMessage.style.display = "block";
      } else {
        // Hide the error message.
        forkFormNewJbErrorMessage.style.display = "none";
      }

      // Show the loading animation.
      startLoadingAnimation('fork-form-new-jb-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      if (forkFormNewJbSubmitButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('fork-form-new-jb-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormNewJbErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            forkFormNewJbErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-new-jb-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const name = forFormProjectNameInput.value;
      const owner = forkFormProjectOwnerInput.value;

      try {
          // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormNewJbErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormNewJbErrorMessage.style.display = "block";

          // Disable the button.
          forkFormNewJbSubmitButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-new-jb-button-loading-animation');
      } catch (e) {
        forkFormNewJbErrorMessage.innerHTML = e;
        forkFormNewJbErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-new-jb-button-loading-animation');
      }
    }
  }

  const decoratePermissionForm = () => {
    const forkFormOperatorProjectIdInput = document.getElementById("fork-form-operator-project-id-input");
    const forkFormPermissionSubmitButton = document.getElementById("fork-form-permission-submit-button");
    const forkFormPermissionErrorMessage = document.getElementById("fork-form-permission-error-message");

    // Submit the form.
    forkFormPermissionSubmitButton.onclick = async () => {
      // Check for empty values.
      if (forkFormOperatorProjectIdInput.value == "") {
        forkFormPermissionErrorMessage.innerHTML = `Missing values.`;
        forkFormPermissionErrorMessage.style.display = "block";
      } else {
        // Hide the error message.
        forkFormPermissionErrorMessage.style.display = "none";
      }

      // Show the loading animation.
      startLoadingAnimation('fork-form-permission-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the form contents make sense.

      if (forkFormPermissionSubmitButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('fork-form-permission-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormPermissionErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            forkFormPermissionErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-permission-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const projectId = forkFormOperatorProjectIdInput.value;

      try {
        // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormPermissionErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormPermissionErrorMessage.style.display = "block";

          // Disable the button.
          forkFormPermissionSubmitButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-permission-button-loading-animation');
      } catch (e) {
        forkFormPermissionErrorMessage.innerHTML = e;
        forkFormPermissionErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-permission-button-loading-animation');
      }
    }
  }

  const decorateAllowanceForm = () => {
    const forkFormAllowanceSubmitButton = document.getElementById("fork-form-permission-submit-button");
    const forkFormMinimumPriceInput = document.getElementById("fork-form-minimum-price-input");
    const forkFormMinimumTotalSupplyInput = document.getElementById("fork-form-minimum-total-supply-input");
    const forkFormMaximumTotalSupplyInput = document.getElementById("fork-form-maximum-total-supply-input");
    const forkFormAllowedAddressesInput = document.getElementById("fork-form-allowed-addresses-input");
    const forkFormAllowanceErrorMessage = document.getElementById("fork-form-allowance-error-message");

    // Submit the form.
    forkFormAllowanceSubmitButton.onclick = async () => {
      // Default to max
      if (forkFormMaximumTotalSupplyInput.value == "") forkFormMaximumTotalSupplyInput.value = 1000000000;
      // Default to 1
      if (forkFormMinimumTotalSupplyInput.value == "") forkFormMinimumTotalSupplyInput.value = 1;
      // Default to free
      if (forkFormMinimumPriceInput.value == "") forkFormMinimumPriceInput.value = 0;

      // Show the loading animation.
      startLoadingAnimation('fork-form-allowance-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the form contents make sense.
      if (forkFormPermissionSubmitButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('fork-form-allowance-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId); 
          } catch (e) {
            forkFormAllowanceErrorMessage.innerHTML = `Browser not connected to ${chain}.`;
            forkFormAllowanceErrorMessage.style.display = "block";

            // Hide the loading animation.
            stopLoadingAnimation('fork-form-allowance-button-loading-animation');

            return;
          }
      }

      // Normalize values from the form.
      const minimumPrice = `${Number(forkFormMinimumPriceInput.value) * 1_000_000_000_000_000_000}`;
      const minimumTotalPrice = forkFormMinimumTotalSupplyInput.value;
      const maximumTotalPrice = forkFormMaximumTotalSupplyInput.value;
      const allowedAddresses = forkFormAllowedAddressesInput.value.split('\n');

      try {
          // Show incompatible network if needed.
        if (!accepted) { 
          // Show the error message.
          forkFormAllowanceErrorMessage.innerHTML = "The connected network isn't supported.";
          forkFormAllowanceErrorMessage.style.display = "block";

          // Disable the button.
          postFormButton.disabled = true;
        }

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-allowance-button-loading-animation');
      } catch (e) {
        forkFormAllowanceErrorMessage.innerHTML = e;
        forkFormAllowanceErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('fork-form-allowance-button-loading-animation');
      }
    }
  }

  // Get the fork modal set up.
  const decorateAndShowForkModal = () => {
    // Get references to elements that need decorating.
    const forkModal = document.getElementById("fork-modal");
 
    // Show the modal.
    forkModal.style.display = "block";

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    forkModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    forkModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("closes-modal")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT") return;

      // Hide the modal.
      forkModal.style.display = "none";
    });
    
    decorateNewJbForm();
    decoratePermissionForm();
    decorateAllowanceForm();
  }

  const setupForking = () => {
    const fork = document.getElementById("fork");

    fork.addEventListener("click", async (e) => {
      e.preventDefault();

      // Make the modal look right.
      await decorateAndShowForkModal();
    });
  }
    
  console.log("umm");
  fetchSettings();
  console.log("summ");
  loadImageFrames();
  console.log("vumm");
  startLoadingAnimation('main-loading-animation');
  console.log("pumm");
  setupForking();
  console.log("mumm");
</script>
{% endblock %}
