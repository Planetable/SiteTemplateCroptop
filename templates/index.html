{% extends 'base.html' %}
{% block head %}
{% include 'modules/deps.html' %}
{% include 'modules/ethers.html' %}
{% include 'modules/utils.html' %}
{% include 'modules/tx.html' %}
{% include 'modules/croptop_publisher.html' %}
{% include 'modules/croptop_deployer.html' %}
{% include 'modules/operator_store.html' %}
{% include 'modules/planet_seo.html' %}
{% endblock %}

{% block dom_ready %}
window.onpopstate = function(event) {
  if (event.state) {
    const postModal = document.getElementById("post-modal");
    postModal.style.display = "none";
  }
};
{% endblock %}

{% block main %}
<div id="top-dom">
  {% include 'modules/header.html' %}
</div>
<div id="body-dom">
  <div id="main-loading-animation" class="loading-animation"></div>
  <div id="frames"></div>
</div>
<div id="fork-modal" class="modal negative-space">
  <div class="modal-content content negative-space">
    <div class="modal-close-button negative-space">[<span class="modal-close-button-text negative-space">close</span>]</div>
    {% include 'modules/fork.html' %}
  </div>
</div>
<div id="post-modal" class="modal negative-space">
  <div class="modal-content content negative-space">
    <div class="modal-close-button negative-space">[<span class="modal-close-button-text negative-space">close</span>]</div>
      {% include 'modules/post.html' %}
  </div>
</div>
<script>
  // Layout constants.
  const horizontalMargin = 24;
  const verticalMargin = 10;
  const transitionDuration = 300;
  const widthClasses = ["w1", "w2", "w3"];
  const formInputReactionTimeDelay = 600;
  const noScrollEffectEdgeDistance = 80;

  // State constants.
  const feeDivisor = 20;

  // Layout variables.
  let frames;
  let items = [];
  let currentRow = 1;
  let greatestRightInRow = 0;
  let rows = [];
  let lastScrollTop = 0;

  // State variables.
  let encodedIPFSUris;
    
  const loadFrameState = async () => { 
    // Load tiers.
    const postFormStateChain = document.getElementById("post-form-state-chain");
    const postFormStateProjectId = document.getElementById("post-form-state-project-id");
    const chain = postFormStateChain.innerHTML;
    const projectId = parseInt(postFormStateProjectId.innerHTML);

    const tiers = await tx_view_tiers(projectId, encodedIPFSUris, resolveChainId(chain));

    for (let i in tiers) {
      const tier = tiers[i];
      if (tier.id != 0) {

        // Cache the value.
        if (!tiersCache[projectId]) tiersCache[projectId] = {};
        tiersCache[projectId][encodedIPFSUris[i]] = tier;

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());
        const frame = frames[i]; 
        const cta = frame.querySelector('.image-cta');

        // Set the content.
        if (formattedRemainingSupply == 0) {
          cta.textContent = '[sold out]';
          cta.classList.add("sold-out");
        } else {
          cta.textContent = `[${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left]`;
        }
      } 
    }
  }
 
  const decorateFrame = (frame, itemId, date, name, link, imageSrc, videoSrc) => {
    // Set a default name if needed.
    if (name === undefined || name === null || name === "") name = "✃";

    const postModal = document.getElementById("post-modal");
      
    // Get references to frame elements that need decorating.
    const cta = frame.querySelector('.image-cta');;
    const title = frame.querySelector('div.image-title');
    const img = frame.querySelector('img');

    // Set the frame and img's ID.
    frame.id = 'frame-' + itemId;
    img.id = 'img-' + itemId;

    // Set the content.
    cta.textContent = '[rec]';
    title.innerHTML = `<span><span class="image-date">${date} | </span>${ name }<span>`;

    // Mark videos with an icon.
    if (videoSrc) {
      const overlay = document.createElement("div");
      overlay.innerHTML = "[▶]"
      overlay.classList.add("overlay-play-icon");
      frame.appendChild(overlay);
    }

    // Summon a modal when the frame is clicked.
    frame.addEventListener("click", async (e) => {
      e.preventDefault();

      // Show the modal.
      postModal.style.display = "block";

      toggleNavVisibility(true);

      // Make the modal look right.
      await decoratePostModal(itemId, await encodeIPFSUriFrom("{{ assets_prefix }}", itemId), name, date, link, imageSrc, videoSrc);
    });
  }

  /// Load the frame contents.
  const loadFrame = async (frame) => {
    const img = frame.querySelector('img:first-of-type');
    return new Promise((resolve) => {
      // Resolve if the image if done.
      if (img.complete) return resolve();

      const checkForDimensions = () => {
        // Resolve if the img has dimensions. Small delay to let more of the img load for a smoother slide in.
        if (img.width > 0 && img.height > 0) return setTimeout(resolve, 1000);
        // Otherwise wait until the image has dimensions.
        else
          return requestAnimationFrame(checkForDimensions);
      }

      checkForDimensions();
    });
  }

  /// Get the top.
  const getTopTarget = (frame, row) => {
    if (row == 1) {
      const frames = document.getElementById("frames");
      return frames.offsetTop;
    } 

    let previousRow = rows[row - 2];
    let candidateFrame;

    for (let j = 0; j < previousRow.frames.length; j++) {
      let frameToCheck = previousRow.frames[j];

      if (
        frame.left < frameToCheck.right + horizontalMargin &&
        frame.right + horizontalMargin > frameToCheck.left &&
        (candidateFrame == null || frameToCheck.bottom > candidateFrame.bottom)
      ) candidateFrame = frameToCheck;
      else if (frame.right <= frameToCheck.left) {
        return candidateFrame ? candidateFrame.bottom : getTopTarget(frame, row - 1);
      }
    }
    
    if (!candidateFrame) {
      console.log({ frame, row, previousRow });
    }
    return candidateFrame.bottom;
  }

  const frameImage = (src) => {
    const frames = document.getElementById("frames");
    const frame = document.createElement("div");
    const header = document.createElement("div");
    const footer = document.createElement("div");
    const title = document.createElement("div");
    const img = document.createElement("img");
    const cta = document.createElement("div");

    frame.classList.add("frame");
    frame.style.transitionProperty = "opacity, margin-top";
    frame.style.transitionDuration = `${transitionDuration / 1000}s, ${transitionDuration / 1000}s`;
    frame.style.transitionTimingFunction = "ease, ease";
    header.classList.add("image-header");
    footer.classList.add("image-footer");
    cta.classList.add("image-cta");
    title.classList.add("image-title");
    img.loading = "lazy";
    img.style.cursor = "pointer";

    // Get random width.
    const widthClass = widthClasses[Math.floor(Math.random() * widthClasses.length)];
    frame.classList.add(widthClass);

    img.src = src;

    header.appendChild(cta);
    header.appendChild(title);
    frame.appendChild(header);
    frame.appendChild(img);
    frames.appendChild(frame);

    return frame;
  }

  const positionAndShowFrame = async (imageFrame) => {
    await loadFrame(imageFrame);

    if (loadingAnimationIntervals['main-loading-animation']) stopLoadingAnimation('main-loading-animation');

    const rect = imageFrame.getBoundingClientRect();
    if (rect.left < greatestRightInRow) currentRow++;
    
    greatestRightInRow = rect.right;

    const heightDiff = rect.top - getTopTarget(rect, currentRow);
      let newFrame = { left: rect.left, right: rect.right, bottom: rect.bottom - heightDiff + verticalMargin };

    if (currentRow > rows.length) rows.push({ frames: [newFrame] });
    else rows[rows.length - 1].frames.push(newFrame);

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const marginTop = window.getComputedStyle(imageFrame).display == "block" ? 0 : heightDiff + scrollTop - verticalMargin;
    imageFrame.classList.add("frame-fade-in");

    return new Promise((resolve) => {
      if (marginTop) {
        const handleEvent = (event) => {
          if (event.propertyName === "margin-top") {
            imageFrame.removeEventListener("transitionend", handleEvent);
            resolve();
          }
        };
        imageFrame.addEventListener("transitionend", handleEvent);
        imageFrame.style.marginTop = -marginTop + "px";
      } else setTimeout(resolve, transitionDuration);
    });
  }

  const decoratePostModal = async (itemId, encodedIPFSUri, name, date, link, imageSrc, videoSrc) => {
    // Get references to modal elements that need decorating.
    const postModal = document.getElementById("post-modal");
    const headerContainer = document.getElementById('header-container');
    const postFormStateReveal = document.getElementById("post-form-state-reveal");
    const postFormErrorMessage= document.getElementById("post-form-error-message");
    const recordPostForm = document.getElementById("record-post-form");
    const collectPostForm = document.getElementById("collect-post-form");
    const postImage = document.getElementById("post-image");
    const postVideo = document.getElementById("post-video");

    // Adjust the size.
    requestAnimationFrame(() => {
      const headerContainerHeight = headerContainer.offsetHeight;
      postModal.style.top = headerContainerHeight + 'px';
      postModal.style.height = `calc(100% - ${headerContainerHeight}px)`;
    });

    // Track the modal in browse history.
    history.pushState({ modalOpened: true, itemId: itemId }, "", "?id=" + itemId);

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    postModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    postModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("negative-space")) return;

      // Ignore if the clicked view comes while an input field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT") return;

      // If there's a video, pause it.
      if (videoSrc) postVideo.pause();

      // Hide the RECORD form.
      recordPostForm.style.display = "none";
      // Hide the COLLECT form.
      collectPostForm.style.display = "none";
      // Hide the error message.
      postFormErrorMessage.style.display = "none";
      // Close the state reveal.
      postFormStateReveal.open = false;
      // Hide the content
      postImage.style.display = "none"
      postVideo.style.display = "none"

      // Hide the modal.
      postModal.style.display = "none";

      toggleNavVisibility(true);

      requestAnimationFrame(adjustBodyTopPadding);     

      // Reset the view stack browsing state.
      history.pushState({}, "", window.location.pathname);
    });

    // Show the loading animation.
    startLoadingAnimation('post-form-loading-animation');
    
    // Show the post page.
    await decoratePostPage(itemId, name, date, link, imageSrc, videoSrc, encodedIPFSUri);

    // Hide the loading animation.
    stopLoadingAnimation('post-form-loading-animation');
  }

  // Get the fork modal set up.
  const decorateForkModal = () => {
    // Get references to elements that need decorating.
    const forkModal = document.getElementById("fork-modal");
    const headerContainer = document.getElementById('header-container');

    // Adjust the size.
    requestAnimationFrame(() => {
      const headerContiainerHeight = headerContainer.offsetHeight;
      forkModal.style.top = headerContiainerHeight + 'px';
      forkModal.style.height = `calc(100% - ${headerContiainerHeight}px)`;
    });

    // Make sure the modal is closeable when clicking on empty space.
    let activeElementOnClose;
    forkModal.addEventListener("mousedown", () => {
      activeElementOnClose = document.activeElement;
    });

    forkModal.addEventListener("click", (e) => {
      // Ignore if the clicked view shouldn't close the modal.
      if (!e.target.classList.contains("negative-space")) return;
        
      // Ignore if the clicked view comes while an input, select, or textarea field is selected.
      if (activeElementOnClose.tagName === "INPUT" || activeElementOnClose.tagName === "SELECT" || activeElementOnClose.tagName === "TEXTAREA") return;

      // Hide the modal.
      forkModal.style.display = "none";

      toggleNavVisibility(true);

      requestAnimationFrame(adjustBodyTopPadding);     
    });
        
    decorateNewJbForm();
    decoratePermissionForm();
    decorateAllowanceForm();
  }

  const setupForking = () => {
    const forkModal = document.getElementById("fork-modal");
    const fork = document.getElementById("fork");

    // Summon a modal when the fork button is clicked.
    fork.addEventListener("click", async (e) => {
      e.preventDefault();
     
      // Show the modal.
      forkModal.style.display = "block";

      toggleNavVisibility(true);
      
      // Make the modal look right.
      await decorateForkModal();
    });
  }

  const loadImageFrames = async () => {
    const response = await fetch(
      `{{ assets_prefix }}planet.json`
    );
    const data = await response.json();
    const itemIds = [];
    frames = data['articles']
      // Only if attachments have file extensions like ".jpg" ".jpeg" ".png" ".gif" ".webp" ".svg" ".avif"
      .filter(item => item.hasVideo === true || item.attachments.some(attachment => attachment.match(/\.(jpg|jpeg|png|gif|webp|svg|avif)$/i)))
      .map((item) => {
        items.push(item);
        // if item.hasVideo, use _videoThumbnail.png
        // else use a random attachment
        const imageName = item.hasVideo ? '_videoThumbnail.png' : item.attachments[Math.floor(Math.random() * item.attachments.length)];
        const videoSrc = item.hasVideo ? './' + item.id + '/' + item.videoFilename : null;
        const imageSrc = './' + item.id + '/' + imageName;
        const frame = frameImage(imageSrc);
        itemIds.push(item.id);
        decorateFrame(frame, item.id, formatTimestamp(item.created), item.title, item.externalLink, imageSrc, videoSrc);
        return frame;
      }
    );

    // if there is ?id= in the url, open the modal
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    if (id) {
      item = items.find(item => item.id == id);
      if (item) {
        const img = document.getElementById('img-' + item.id);
          if (img) setTimeout(() => img.click(), 200);
      }
    }
    
    encodedIPFSUris = await Promise.all(itemIds.map(async (itemId) => await encodeIPFSUriFrom("{{ assets_prefix }}", itemId)));

    const positionAndShowFrames = async () => {
      for (const frame of frames)
        await positionAndShowFrame(frame);
    };

    await Promise.all([loadFrameState(), positionAndShowFrames()]);
  }
  
  const toggleNavVisibility = (force) => {
    const topDom = document.getElementById('top-dom');
    const navContainer = document.getElementById('nav-container');
    const postModal = document.getElementById('post-modal');
    const forkModal = document.getElementById('fork-modal');
    const headerContainer = document.getElementById('header-container');

    if (!navContainer) return;

    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
    const maxScrollTop = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    
    if (force || lastScrollTop > noScrollEffectEdgeDistance && maxScrollTop - lastScrollTop > noScrollEffectEdgeDistance) {
      if (currentScrollTop > lastScrollTop || postModal.style.display == "block" || forkModal.style.display == "block") {
        navContainer.style.visibility = "hidden";
        navContainer.style.opacity = 0;
        delete navContainer.style.transitionDelay;
        navContainer.style.transitionDelay = "0s";
        headerContainer.style.borderBottom = window.getComputedStyle(navContainer).borderBottom;
        navContainer.classList.add('hidden');
        topDom.style.height = headerContainer.offsetHeight + "px";
      } else {
        navContainer.style.visibility = "visible";
        navContainer.style.opacity = 1;
        headerContainer.style.borderBottom = "none";
        navContainer.classList.remove('hidden');
        topDom.style.height = headerContainer.offsetHeight + navContainer.offsetHeight + "px";
      }
    }

    lastScrollTop = currentScrollTop;
  }

  const adjustBodyTopPadding = () => {
    const topDom = document.getElementById('top-dom');
    const bodyDom = document.getElementById('body-dom');
    bodyDom.style.paddingTop = topDom.offsetHeight + 'px';
  }

  window.addEventListener("load", adjustBodyTopPadding);
  window.addEventListener("resize", adjustBodyTopPadding);
  window.addEventListener("scroll", () => toggleNavVisibility(false));

  startLoadingAnimation('main-loading-animation');
  loadSettings();
  loadImageFrames();
  setupForking();
</script>
{% endblock %}
