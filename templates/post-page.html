<div id="post-header" class="post-header body-header mobile-padding negative-space">
  <div id="post-title">
    <div id="post-date"></div>
    <div id="post-name"></div>
  </div>
  <div id="post-subtitle" class="negative-space">
      <span id="post-link"></span>
  </div>
</div>
<div id="post-onchain" class="full-width mobile-padding">
  <details id="post-form-collect-reveal">
    <summary id="post-form-collect-toggle" class="form-toggle">buy & collect</summary>
    <div id="post-form-collect-container">
    <div id="post-form-state-chain-section" class="form-section">
      <div class="form-item">
        <div class="form-value form-select-value">
          <select id="post-form-state-chain-input" name="chain">
            <!-- options will be added by JS -->
          </select>
        </div>
      </div>
      </div>
      <div id="collect-post-form" class="form negative-space">
        <span id="collect-post-form-header" class="form-header"></span>
        <div class="form-body">
            <div class="form-item" style="display: none;">
              <div class="form-label">Collection address</div>
              <div class="form-value"><input type="text" placeholder="0x..." value="" id="post-form-state-collection-address-input" min="1"></div>
            </div>
            <div class="form-item" style="display: none;">
              <div class="form-label">Collection category</div>
              <div class="form-value"><input type="number" value="" id="post-form-state-collection-category-input" min="1"></div>
            </div>
          </div>
          <div class="form-section">
            <div class="form-item">
              <div class="form-label">Copies to buy</div>
              <div class="form-value">
                <input type="number" value="1" id="collect-post-form-quantity-input" min="1" class="form-quantity-input">
              </div>
            </div>
          </div>
        </div>
      <div id="record-post-form" class="form negative-space">
        <span id="record-post-form-header" class="form-header">Buy a first copy to support the author, become a collector, and memorialize the post onchain.</span>
        <div class="form-body">
          <details id="record-post-form-options-reveal">
            <summary id="record-post-form-options-toggle" class="form-toggle form-main-toggle">options</summary>
            <div class="form-section">
              <div class="form-item">
                <div class="form-label">Copies to buy</div>
                <div class="form-value">
                  <input type="number" value="1" id="record-post-form-quantity-input" min="1" class="form-quantity-input">
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>
      <div id="post-form-loading-animation" class="loading-animation"></div>
      <div id="post-form-error-message" class="form-error-message"></div>
      <button id="post-form-button" class="form-button form-main-button"><span id="post-form-button-text" class="form-button-text">buy</span><span id="post-form-button-loading-animation" class="loading-animation button-loading-animation"></span></button>
    </div>
  </details>
</div>
<img id="post-cover-image"></img>
<video id="post-cover-video"></video>
<div id="post-cover-audio-container" class="mobile-padding">
  <audio id="post-cover-audio"></audio>
</div>
<div id="post-content" class="mobile-padding"></div>
<div id="post-attachments" class="mobile-padding"></div>
<div id="post-aggregation" class="mobile-padding"></div>
<script>

  // Configuration constants
  const PostCONFIG = {
    feeDivisor: 20,
    formInputReactionTimeDelay: 600,
    defaultChain: "ethereum sepolia",
    defaultCollectionCategory: 0,
    highlightColor: "#f056c1"
  };

  // Cache DOM elements for better performance
  const PostDOM = {
    postFormErrorMessage: document.getElementById("post-form-error-message"),
    postFormButton: document.getElementById("post-form-button"),
    postFormButtonText: document.getElementById("post-form-button-text"),
    postFormButtonLoadingAnimation: document.getElementById("post-form-button-loading-animation"),
    postFormLoadingAnimation: document.getElementById("post-form-loading-animation"),
    postFormStateChainInput: document.getElementById("post-form-state-chain-input"),
    postFormStateChainSection: document.getElementById("post-form-state-chain-section"),
    postFormStateCollectionAddressInput: document.getElementById("post-form-state-collection-address-input"),
    postFormStateCollectionCategoryInput: document.getElementById("post-form-state-collection-category-input"),
    postName: document.getElementById("post-name"),
    postDate: document.getElementById("post-date"),
    postSubtitle: document.getElementById("post-subtitle"),
    postLink: document.getElementById("post-link"),
    postCoverImage: document.getElementById("post-cover-image"),
    postCoverVideo: document.getElementById("post-cover-video"),
    postCoverAudioContainer: document.getElementById("post-cover-audio-container"),
    postCoverAudio: document.getElementById("post-cover-audio"),
    postContent: document.getElementById("post-content"),
    recordPostForm: document.getElementById("record-post-form"),
    collectPostForm: document.getElementById("collect-post-form"),
    postFormCollectReveal: document.getElementById("post-form-collect-reveal"),
    postFormCollectToggle: document.getElementById("post-form-collect-toggle"),
    recordPostFormQuantityInput: document.getElementById("record-post-form-quantity-input"),
    recordPostFormOptionsReveal: document.getElementById("record-post-form-options-reveal"),
    collectPostFormQuantityInput: document.getElementById("collect-post-form-quantity-input"),
    collectPostFormHeader: document.getElementById("collect-post-form-header"),
    postAttachments: document.getElementById("post-attachments"),
    postAggregation: document.getElementById("post-aggregation"),
    postOnchain: document.getElementById("post-onchain")
  };

  let tiersCache = {};
  let allowanceCache = {};
  let highlightColor = PostCONFIG.highlightColor;
  let signer;

  // Error handling utilities
  const showError = (message, type = "warn") => {
    PostDOM.postFormErrorMessage.innerHTML = message;
    PostDOM.postFormErrorMessage.classList.add(type);
    PostDOM.postFormErrorMessage.style.display = "block";
  };

  const hideError = () => {
    PostDOM.postFormErrorMessage.style.display = "none";
  };

  const showButton = (enabled = true) => {
    PostDOM.postFormButton.disabled = !enabled;
    PostDOM.postFormButton.style.display = "block";
  };

  const hideButton = () => {
    PostDOM.postFormButton.disabled = true;
    PostDOM.postFormButton.style.display = "none";
  };

  const loadAndRenderArticle = (articleID) => {
    return fetch(`{{ assets_prefix }}${articleID}/article.json`)
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        return renderMarkdown(data.content);
      });
  }

  /// Get admin settings.
  const loadSettings = () => {

    fetch("{{ assets_prefix }}templateSettings.json?t={{ build_timestamp }}")
      // only if response is 200 OK, parse the JSON
      .then(response => {
        if (!response.ok) {
          throw Error(response.statusText); // Throw an error if response is not OK.
        }
        return response.json();
      })
      .then(data => {
        env = {
          ...env,
          ...data
        };
        console.log({ env, data });
        // Dynamically populate chain select with only chains that have a collection address
        const fullChainMap = [
          { chainId: 1, address: data.ethereumMainnetCollectionAddress },
          { chainId: 10, address: data.optimismMainnetCollectionAddress },
          { chainId: 42161, address: data.arbitrumMainnetCollectionAddress },
          { chainId: 8453, address: data.baseMainnetCollectionAddress },
          { chainId: 11155111, address: data.ethereumSepoliaCollectionAddress },
          { chainId: 11155420, address: data.optimismSepoliaCollectionAddress },
          { chainId: 84532, address: data.arbitrumSepoliaCollectionAddress },
          { chainId: 84532, address: data.baseSepoliaCollectionAddress },
        ];
        const chainMap = fullChainMap.filter(chain => chain.address).map(chain => ({
          value: resolveChain(chain.chainId),
          label: resolveChainLabel(chain.chainId),
          address: chain.address,
          category: data.collectionCategory || 0
        }));
        console.log({ chainMap });
        // Clear and repopulate the select
        PostDOM.postFormStateChainInput.innerHTML = '';
        chainMap.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          PostDOM.postFormStateChainInput.appendChild(option);
        });
        // Set default values
        if (chainMap.length > 0) {
          PostDOM.postFormStateChainInput.value = chainMap[0].value;
          PostDOM.postFormStateCollectionAddressInput.value = chainMap[0].address;
          PostDOM.postFormStateCollectionCategoryInput.value = chainMap[0].category;
        }
        if (data.highlightColor) highlightColor = data.highlightColor;
        const r = document.querySelector(':root');
        r.style.setProperty('--link-color', highlightColor);
      })
      .catch(error => {
        console.error('Error occurred when fetching templateSettings.json:', error);
        // Set highlightColor with the default value
        const r = document.querySelector(':root');
        r.style.setProperty('--link-color', highlightColor);
      });
  }

  const updateRecordFormHeader = (chain, formattedMinPrice, formattedMinTotalSupply) => {
    const chainId = resolveChainId(chain);
    const chainLabel = resolveChainLabel(chainId);
    // Note: recordPostFormHeader is not in our DOM cache as it's dynamically created
    const recordPostFormHeader = document.getElementById("record-post-form-header");
    if (recordPostFormHeader) {
      recordPostFormHeader.innerHTML = `Price: <span class="ether">Ξ</span>${formattedMinPrice}  <span class="form-header-separator">|</span>  Copies left: ${formattedMinTotalSupply}`;
    }
  }

  const decorateRecordForm = async (chain, collectionAddress, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses) => {

    // Update the header text with the current chain
    updateRecordFormHeader(chain, formattedMinPrice, formattedMinTotalSupply);

    // Toggle off the options section by default
    PostDOM.recordPostFormOptionsReveal.open = false;

    // Disable the button.
    hideButton();

    // Change the button text.
    PostDOM.postFormButtonText.innerHTML = "buy";


    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error message if not allowed.
      if (signer && formattedAllowedAddresses.length && !formattedAllowedAddresses.includes(signer)) {
        showError(`Collection ${collectionAddress} has reserved posting to category ${category} for these addresses: ${formattedAllowedAddresses}.`);
        showButton(false);
      } else if (Number(PostDOM.recordPostFormQuantityInput.value) > Number(formattedMinTotalSupply)) {
        showError(`There are only ${formattedMinTotalSupply} copies left. Can't buy ${PostDOM.recordPostFormQuantityInput.value}.`);
        showButton(false);
      } else {
        // Hide the error message.
        hideError();
        showButton(true);
      }
    }

    // Add event listener for quantity input changes
    PostDOM.recordPostFormQuantityInput.addEventListener("input", checkState);

    // Set default quantity if not set
    if (!PostDOM.recordPostFormQuantityInput.value) PostDOM.recordPostFormQuantityInput.value = 1;


    // Submit the form.
    PostDOM.postFormButton.onclick = async () => {
      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Make sure the form contents make sense.
      await checkState();

      if (PostDOM.postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
          try {
            await switchChain(expectedChainId);
          } catch (e) {
            showError(`Browser not connected to ${chain}.`);

            // Hide the loading animation.
            stopLoadingAnimation('post-form-button-loading-animation');

            return;
          }
      }

      // Use simplified values: min price, supply as total supply, quantity from input, default addresses
      const totalSupply = formattedMinTotalSupply;
      const quantity = PostDOM.recordPostFormQuantityInput.value;
      const price = fixedPointNumber(formattedMinPrice, 18);
      const beneficiary = signer; // Use signer's address as default
      const cpnBeneficiary = resolveCPNBeneficiaryAddress(chain) || signer; // Use default CPN beneficiary
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((collectionAddress == await cpnCollectionAddress(chain)) ? BigInt(0) : (totalPrice / BigInt(PostCONFIG.feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(collectionAddress, category, totalSupply, price, quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));

          // Show incompatible network if needed.
        if (!accepted) {
          // Show the error message.
          showError("The connected network isn't supported.", "info");

          // Hide and disable the button.
          hideButton();
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        postFormErrorMessage.innerHTML = e;
        postFormErrorMessage.classList.add("warn");
        postFormErrorMessage.style.display = "block";

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  const decorateCollectForm = async (chain, collectionAddress, category, encodedIPFSUri, formattedMintedSupply, formattedRemainingSupply, formattedPrice) => {


    // Set the header text.
    if (formattedRemainingSupply == 1) {
      PostDOM.collectPostFormHeader.innerHTML = `${formattedMintedSupply} bought, only 1 copy of this post left for <span class="ether">Ξ</span>${formattedPrice}.`;
    } else {
      PostDOM.collectPostFormHeader.innerHTML = `${formattedMintedSupply} bought, ${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } copies left for <span class="ether">Ξ</span>${formattedPrice} each.`;
    }

    // Change the button text.
    PostDOM.postFormButtonText.innerHTML = "buy";

    // Disable the button.
    hideButton();

    // Set the correct link given the chain.
    // Note: collectPostFormCpnAnchor element not found in HTML, skipping href assignment

    // Re-decorate some input fields depending on the allowances set for the project and category.
    const checkState = async () => {
      // Set error messages if the currently inputted values are too small.
      if (Number(PostDOM.collectPostFormQuantityInput.value) > formattedRemainingSupply) {
        if (formattedRemainingSupply == 1) {
          showError(`There is only 1 copy left. Can't buy ${PostDOM.collectPostFormQuantityInput.value}.`);
        } else {
          showError(`There are only ${formattedRemainingSupply} copies left. Can't buy ${PostDOM.collectPostFormQuantityInput.value}.`);
        }
        showButton(false);
      } else {
        // Hide the error message.
        hideError();
        showButton(true);
      }
    }

    // Prevent excessive calls.
    let checkStateTimer;
    const queueCheckState = async () => {
      clearTimeout(checkStateTimer);
      checkStateTimer = setTimeout(checkState, PostCONFIG.formInputReactionTimeDelay);
    }

    // Update the form's state each time the price or quantity changes.
    PostDOM.collectPostFormQuantityInput.addEventListener("input", queueCheckState);

    // Set values in the form if the fields are not yet set.
    // Note: collectPostFormBeneficiaryInput is not in our DOM cache as it may not exist
    const collectPostFormBeneficiaryInput = document.getElementById("collect-post-form-beneficiary-input");
    if (collectPostFormBeneficiaryInput && !collectPostFormBeneficiaryInput.value && signer) {
      collectPostFormBeneficiaryInput.value = signer;
    }

    // Allow connecting wallet to prefill beneficiary input field.
    const loadAddressButton = document.getElementById("collect-post-form-load-address-button");
    if (loadAddressButton) {
      loadAddressButton.onclick = async () => {
        signer = (await getSigner()).address;
        if (collectPostFormBeneficiaryInput) {
          collectPostFormBeneficiaryInput.value = signer;
        }
        await checkState();
      };
    }

    // Submit the form.
    PostDOM.postFormButton.onclick = async () => {
      // Check for empty values.
      if (!PostDOM.collectPostFormQuantityInput.value) {
        showError("Fill out the form.");
        return;
      }

      // Show the loading animation.
      startLoadingAnimation('post-form-button-loading-animation');

      // Get the signer.
      signer = (await getSigner()).address;

      // Default to the signer.
      if (collectPostFormBeneficiaryInput && !collectPostFormBeneficiaryInput.value) {
        collectPostFormBeneficiaryInput.value = signer;
      }
      // Default to the eth address, or the signer;
      const collectPostFormCpnBeneficiaryInput = document.getElementById("collect-post-form-cpn-beneficiary-input");
      if (collectPostFormCpnBeneficiaryInput && !collectPostFormCpnBeneficiaryInput.value) {
        collectPostFormCpnBeneficiaryInput.value = resolveCPNBeneficiaryAddress(chain) || signer;
      }

      // Make sure the form contents make sense.
      await checkState();

      if (PostDOM.postFormButton.disabled) {
        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');

        return;
      }

      // Make sure the client is connected to the right network.
      const chainId = await getChainId();
      const expectedChainId = resolveChainId(chain);
      if (chainId != expectedChainId) {
        try {
          await switchChain(expectedChainId);
        } catch (e) {
          showError(`Browser not connected to ${chain}.`, "info");

          // Hide the loading animation.
          stopLoadingAnimation('post-form-button-loading-animation');

          return;
        }
      }

      // Normalize values from the form.
      const totalSupply = 1;
      const price = fixedPointNumber(formattedPrice, 18);
      const quantity = PostDOM.collectPostFormQuantityInput.value;
      const beneficiary = signer; // Use signer's address as default
      const cpnBeneficiary = resolveCPNBeneficiaryAddress(chain) || signer; // Use default CPN beneficiary
      // Add a fee if the project being paid isn't the fee collectionAddress.
      const totalPrice = BigInt(price) * BigInt(quantity);
      const value = totalPrice + ((collectionAddress == await cpnCollectionAddress(chain)) ? BigInt(0) : (totalPrice / BigInt(PostCONFIG.feeDivisor)));

      try {
        // Try to process the transaction.
        const accepted = await tx_collect(collectionAddress, category, totalSupply, BigInt(price), quantity, encodedIPFSUri, beneficiary, cpnBeneficiary, value, resolveChainId(chain));
        // Show incompatible network if needed.
        if (!accepted) {
          // Show the error message.
          showError("The connected network isn't supported.", "info");

          // Disable the button.
          hideButton();
        }

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      } catch (e) {
        showError(e);

        // Hide the loading animation.
        stopLoadingAnimation('post-form-button-loading-animation');
      }
    }

    // Check the state.
    await checkState();
  }

  const decoratePostBody = () => {
      const firstChild = PostDOM.postContent.firstChild;
  }

  const getCleanerURL = (url) => {
    const parsedUrl = new URL(url);
    return `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.pathname}`;
  }

  // Re-decorate the form depending on if the provided content has already been recorded onchain, and if it's sold out.
  const decoratePostPage = async (postId, name, date, link, content, imageSrc, videoSrc, audioSrc, encodedIPFSUri, thumbnailAutogenerated, slug="") => {
    // Show the loading animation.
    startLoadingAnimation('post-form-loading-animation');
    let postContentHasImgTags = false;
    if (content) {
      PostDOM.postContent.style.display = "block";
      PostDOM.postContent.innerHTML = content;
      let imgs = PostDOM.postContent.getElementsByTagName("img");
      for (let img of imgs) {
        let src = img.getAttribute("src");
        if (src) {
          postContentHasImgTags = true;
        }
        if (!src.startsWith("https://") && !src.startsWith("http://") && !src.startsWith("/")) {
          // Fix relative paths for homepage.
          // No need to fix on /UUID/ pages.
          // No need to fix on /slug/ pages.
          let prefix = getCleanerURL(window.location.href);
          if (slug.length > 0) {
            if (!prefix.includes(slug) && !prefix.includes(postId)) {
              let fixedSrc = `${prefix}${slug}/${src}`;
              img.setAttribute("src", fixedSrc);
            } else {
              console.log(`No need to fix prefix for ${src}`);
            }
          } else {
            if (!prefix.includes(postId)) {
              let fixedSrc = `${prefix}${postId}/${src}`;
              img.setAttribute("src", fixedSrc);
            } else {
              console.log(`No need to fix prefix for ${src}`);
            }
          }
          // Old behavior: remove all relative images because the designated hero image is shown in postCoverImage tag.
          // postContent.removeChild(img);
        }
      }
    } else {
      PostDOM.postContent.style.display = "none";
    }

    // Hide the form.
    PostDOM.collectPostForm.style.display = "none";
    PostDOM.recordPostForm.style.display = "none";

    // Decorate the frame's title.
    PostDOM.postName.innerHTML = name;
    PostDOM.postDate.innerHTML = `${date} `;

    // Reset the label for the collect toggle.
    let storedPostFormCollectToggleText;

    // Show and populate the frame's subtitle if there's a link.
    if (link) {
      PostDOM.postSubtitle.style.display = "block";
      PostDOM.postLink.innerHTML = `<a href="${link}" target="_blank">${link}</a>`;
    } else {
      PostDOM.postSubtitle.style.display = "none";
    }

    // Decorate the image or video content.

    if (videoSrc) {
      PostDOM.postCoverImage.style.display = "none";
      PostDOM.postCoverAudioContainer.style.display = "none";
      PostDOM.postCoverVideo.style.display = "block";
      PostDOM.postCoverVideo.autoplay = true;
      PostDOM.postCoverVideo.loop = true;
      PostDOM.postCoverVideo.muted = true;
      PostDOM.postCoverVideo.controls = true;
      PostDOM.postCoverVideo.playsInline = true;
      PostDOM.postCoverVideo.preload = "auto";
      PostDOM.postCoverVideo.poster = "{{ assets_prefix }}" + postId + "/_videoThumbnail.png";
      PostDOM.postCoverImage.src = "";
      PostDOM.postCoverVideo.src = videoSrc;
      PostDOM.postCoverVideo.addEventListener("click", (e) => e.stopPropagation());
    } else if (audioSrc) {
      const postCoverAudioSource = document.createElement("source");
      PostDOM.postCoverImage.style.display = "none"
      PostDOM.postCoverVideo.style.display = "none"
      PostDOM.postCoverAudioContainer.style.display = "block";
      PostDOM.postCoverAudio.autoplay = false;
      PostDOM.postCoverAudio.loop = false;
      PostDOM.postCoverAudio.muted = false;
      PostDOM.postCoverAudio.controls = true;
      postCoverAudioSource.src = audioSrc;
      PostDOM.postCoverVideo.src = "";
      PostDOM.postCoverImage.src = "";
      PostDOM.postCoverAudio.appendChild(postCoverAudioSource);
    } else if (imageSrc && postContentHasImgTags) {
      PostDOM.postCoverVideo.src = "";
      PostDOM.postCoverVideo.style.display = "none";
      PostDOM.postCoverImage.src = "";
      PostDOM.postCoverImage.style.display = "none";
      PostDOM.postCoverAudioContainer.style.display = "none";
    } else if (imageSrc && !thumbnailAutogenerated && !postContentHasImgTags) {
      PostDOM.postCoverImage.style.display = "block"
      PostDOM.postCoverVideo.style.display = "none"
      PostDOM.postCoverAudioContainer.style.display = "none";
      PostDOM.postCoverVideo.src = "";
      PostDOM.postCoverImage.src = imageSrc;
      PostDOM.postCoverImage.addEventListener("click", (e) => e.stopPropagation());
    } else {
      PostDOM.postCoverImage.style.display = "none"
      PostDOM.postCoverVideo.style.display = "none"
      PostDOM.postCoverAudioContainer.style.display = "none";
      PostDOM.postCoverVideo.src = "";
      PostDOM.postCoverImage.src = "";
    }

    const updateFormState = async () => {
      // Get a reference to the chain, collectionAddress, and category fields.
      const chain = PostDOM.postFormStateChainInput.value;
      const collectionAddress = PostDOM.postFormStateCollectionAddressInput.value;
      const category = parseInt(PostDOM.postFormStateCollectionCategoryInput.value);

      // Set a chain object.
      if (!tiersCache[chain]) tiersCache[chain] = {};

      // Look in the cache for tiers within the collectionAddress.
      const collectionTiers = tiersCache[chain][collectionAddress];

      // If there's no cache for the collectionAddress, set it to an empty object.
      if (!collectionTiers) tiersCache[chain][collectionAddress] = {};

      // Look in the cache for a tier for the collectionAddress and encodedIPFSUri.
      let tier = tiersCache[chain][collectionAddress][encodedIPFSUri];

      // If nothing is cached, load from the contract.
      if (!tier) {
        // Check to see if there's a tier for this content.
        [tier] = await tx_view_tiers(collectionAddress, [encodedIPFSUri], resolveChainId(chain));

        // If no tier, don't show the form.
        if (!tier) {
          // Show the error message.
          showError("-", "info");
          // Hide the forms.
          PostDOM.recordPostForm.style.display = "none";
          PostDOM.collectPostForm.style.display = "none";
          // Disable the button.
          hideButton();
          PostDOM.postFormCollectToggle.innerHTML = 'buy & collect';
          return;
        }

        // Cache the value.
        tiersCache[chain][collectionAddress][encodedIPFSUri] = tier;
      }

      // Get a reference to the tier's ID.
      const formattedTierId = parseInt(tier[0].toString());


      // If there is no tier, the form's state is in RECORD mode, meaning the content must be recorded onchain before it can be collected.
      if (formattedTierId != 0) {
        // The form's state is in COLLECT mode, meaning new editions can be minted from an already-recorded NFT tier.

        // Get a reference to the tier's remaining supply.
        const formattedRemainingSupply = parseInt(tier[2].toString());

        // If there's no remaining supply, the form's state is in SOLD_OUT mode, meaning it can't be minted anymore.
        if (formattedRemainingSupply == 0) {
          // Show the error message.
          showError("This post is sold out", "info");
          // Hide the forms.
          PostDOM.recordPostForm.style.display = "none";
          PostDOM.collectPostForm.style.display = "none";
          // Disable the button.
          hideButton();
          PostDOM.postFormCollectToggle.innerHTML = 'sold out';
          return;
        }

        // Show the COLLECT form.
        PostDOM.collectPostForm.style.display = "block";
        // Hide the RECORD form.
        PostDOM.recordPostForm.style.display = "none";
        // Hide the error message.
        hideError();

        // Get a reference to the tier's price.
        const formattedPrice = ethers.formatEther(tier[1]);
        const formattedInitialSupply = parseInt(tier[3].toString());

        // The supply that has been minted.
        const formattedMintedSupply = formattedInitialSupply - formattedRemainingSupply;

        if (formattedRemainingSupply == 1) {
          PostDOM.postFormCollectToggle.innerHTML = `${formattedMintedSupply} bought, only 1 left`;
        } else {
          PostDOM.postFormCollectToggle.innerHTML = `${formattedMintedSupply} bought, ${formattedRemainingSupply > 10000000 ? "infinite" : formattedRemainingSupply } left`;
        }

        // Show the form.
        await decorateCollectForm(chain, collectionAddress, category, encodedIPFSUri, formattedMintedSupply, formattedRemainingSupply, formattedPrice);
      } else {
        // Check to see if the project and category allow posting.

        // Look in the cache for allowances within the collectionAddress.
        const collectionAllowances = allowanceCache[collectionAddress];

        // If there's no cache for the collectionAddress, set it to an empty object.
        if (!collectionAllowances) allowanceCache[collectionAddress] = {};

        // Look in the cache for an allowance for the category within the allowances for the collection.
        let allowance = allowanceCache[collectionAddress][category];


        // If nothing is cached, load from the contract.
        if (!allowance) {
          // Get the allowance.
          allowance = await tx_view_allowance(collectionAddress, category, resolveChainId(chain));

          // Cache the value.
          allowanceCache[collectionAddress][category] = allowance;
        }

        // Get a reference to the allowance min total supply.
        const formattedMinTotalSupply = parseInt(allowance[1].toString());

        // Show an error message if there's no allowance set.
        if (formattedMinTotalSupply == 0) {
          // Hide the chain selector if no chain is selected.
          PostDOM.postFormStateChainSection.style.display = chain ? "block" : "none";
          // Show the error message.
          showError(chain ? `This site isn't accepting buys on ${chain} yet. Click "$" up top.` : `This site isn't accepting buys yet. Click "$" up top.`, "info");
          // Hide forms.
          PostDOM.recordPostForm.style.display = "none";
          PostDOM.collectPostForm.style.display = "none";
          // Hide and disable the button.
          hideButton();
          PostDOM.postFormCollectToggle.innerHTML = 'buy & collect';
          return;
        }

        // Show the RECORD form.
        PostDOM.recordPostForm.style.display = "block";
        // Hide the COLLECT form.
        PostDOM.collectPostForm.style.display = "none";
        // Hide the error message.
        hideError();

        // Get a reference to the allowance min price.
        const formattedMinPrice = ethers.formatEther(allowance[0]);

        // Get a reference to the allowance max total supply.
        const formattedMaxTotalSupply = parseInt(allowance[2].toString());

        // Get a reference to the allowance max total supply.
        const formattedAllowedAddresses = allowance[3];

        PostDOM.postFormCollectToggle.innerHTML = 'buy & collect';

        await decorateRecordForm(chain, collectionAddress, category, encodedIPFSUri, formattedMinTotalSupply, formattedMaxTotalSupply, formattedMinPrice, formattedAllowedAddresses);
      }
    }

    // Change the collectionAddress input on network change to the default.
    PostDOM.postFormStateChainInput.addEventListener("change", async () => {
      PostDOM.postFormStateCollectionAddressInput.value = resolveCollectionAddress(PostDOM.postFormStateChainInput.value);

      // Set the collection category value to the default if it hasn't changed.
      PostDOM.postFormStateCollectionCategoryInput.value = resolveCollectionCategory(PostDOM.postFormStateChainInput.value);

      // Update the record form header with the new chain
      updateRecordFormHeader(PostDOM.postFormStateChainInput.value, formattedMinPrice, formattedMinTotalSupply);

      // Show the loading animation.
      startLoadingAnimation('post-form-loading-animation');
      
      console.log("loading started");

      // Update the form's state.
      await updateFormState();

      console.log("loading should be ending");

      // Stop the loading animation.
      stopLoadingAnimation('post-form-loading-animation');
    });

    await updateFormState();

    decoratePostBody();

    // Hide the loading animation.
    stopLoadingAnimation('post-form-loading-animation');
  }

  const decorateAttachments = async (post) => {
    PostDOM.postAttachments.innerHTML = '';
    const previousPreview = document.getElementById("preview-pdf");
    if (previousPreview) {
      previousPreview.remove();
    }
    for (const attachment of post.attachments) {
      const attachmentFullURL = "{{ assets_prefix }}" + post.id + "/" + attachment;
      if (attachment.endsWith(".pdf")) {
        const preview = document.createElement("embed");
        preview.src = attachmentFullURL;
        preview.className = "preview-pdf";
        preview.id = "preview-pdf";

        if (PostDOM.postCoverImage) {
          PostDOM.postCoverImage.style.display = "none";
        }

        if (PostDOM.postOnchain) {
          PostDOM.postOnchain.parentNode.insertBefore(preview, PostDOM.postOnchain.nextSibling);
        }

        const link = document.createElement("a");
        link.href = attachmentFullURL;
        link.target = "_blank";
        link.innerHTML = attachment;
        link.className = "attachment-link";
        PostDOM.postAttachments.appendChild(link);

        PostDOM.postAttachments.style.paddingTop = "1em";
      }
    }
  }

  const decorateAggregation = async (post) => {
    PostDOM.postAggregation.innerHTML = '';
    const originalSiteDomain = post.originalSiteDomain;
    const originalSiteName = post.originalSiteName;
    const originalPostID = post.originalPostID;
    if (originalSiteDomain && originalSiteName && originalPostID) {
      let url = "https://"
      if (originalSiteDomain.startsWith("k51")) {
        url = url + originalSiteDomain + ".eth.sucks";
      }
      else if (originalSiteDomain.endsWith(".eth")) {
        url = url + originalSiteDomain + ".sucks";
      }
      else {
        url = url + originalSiteDomain;
      }
      url = url + "/" + originalPostID + "/";
      const link = document.createElement("a");
      link.href = url;
      link.target = "_blank";
      link.innerHTML = "Posted by " + originalSiteDomain;
      link.className = "aggregation-link";
      PostDOM.postAggregation.appendChild(link);
      PostDOM.postAggregation.style.paddingTop = "1em";
    }
  }
</script>
{% if article_type == 1 %}
<script>
  PostDOM.postOnchain.style.display = "none";
</script>
{% endif %}
